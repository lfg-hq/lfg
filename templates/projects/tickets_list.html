<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% if current_project %}{{ current_project.name }} - Tickets{% else %}Tickets{% endif %} - LFG ðŸš€</title>
    <!-- Theme Variables (must load first) -->
    <link rel="stylesheet" href="/static/css/theme-variables.css">
    <link rel="stylesheet" href="/static/css/common.css">
    <link rel="stylesheet" href="/static/css/sidebar.css">
    <link rel="stylesheet" href="/static/css/tickets.css?v=5">
    <!-- Light Mode Overrides -->
    <link rel="stylesheet" href="/static/css/light/light-mode.css?v=5">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="icon" type="image/x-icon" href="/static/images/favicon.ico">
    <meta name="color-scheme" content="dark light">
    <!-- Theme Switcher (load early to prevent flash) -->
    <script src="/static/js/theme-switcher.js?v=3"></script>
    <style>
        /* Execution logs styles */
        .execution-summary {
            background: var(--surface-secondary, #1a1a1a);
            border: 1px solid var(--border-color, #333);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
        }

        .execution-summary h4 {
            margin: 0 0 0.75rem 0;
            color: var(--text-primary, #fff);
            font-size: 0.95rem;
            font-weight: 600;
        }

        .execution-summary h4 i {
            margin-right: 0.5rem;
            color: var(--accent-color, #4A90E2);
        }

        .execution-logs-container h4 {
            color: var(--text-primary, #fff);
            font-size: 0.95rem;
            font-weight: 600;
            margin: 0 0 1rem 0;
        }

        .execution-logs-container h4 i {
            margin-right: 0.5rem;
            color: var(--accent-color, #4A90E2);
        }

        .execution-log-entry {
            /* padding: 0.15rem 0; */
            /* border-bottom: 1px solid rgba(255, 255, 255, 0.05); */
        }

        .execution-log-entry:last-child {
            border-bottom: none;
        }

        .log-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding: 0.5rem;
            margin: -0.5rem;
            margin-bottom: 0.5rem;
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        .log-header:hover {
            background-color: rgba(255, 255, 255, 0.03);
        }

        .log-command-num {
            font-weight: 300;
            color: var(--text-primary, #fff);
            font-size: 0.875rem;
        }

        .log-timestamp {
            font-size: 0.75rem;
            color: var(--text-secondary, #888);
        }

        .log-explanation {
            color: var(--text-secondary, #aaa);
            font-size: 0.875rem;
            font-weight: 400;
        }

        .log-explanation-detail {
            background: rgba(74, 144, 226, 0.08);
            padding: 0.625rem 0.875rem;
            border-left: 3px solid var(--accent-color, #4A90E2);
            color: var(--text-secondary, #ccc);
            font-size: 0.875rem;
            margin-bottom: 0.75rem;
            font-style: italic;
            border-radius: 4px;
        }

        .log-command {
            background: rgba(255, 255, 255, 0.02);
            padding: 0.5rem 0.75rem;
            border-left: 2px solid var(--accent-color, #4A90E2);
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', monospace;
            font-size: 0.8125rem;
            color: #4EC9B0;
            margin-bottom: 0.5rem;
            overflow-x: auto;
            white-space: pre;
        }

        .log-output {
            background: rgba(0, 0, 0, 0.3);
            padding: 0.5rem 0.75rem;
            border-left: 2px solid rgba(255, 255, 255, 0.1);
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', monospace;
            font-size: 0.8125rem;
            color: var(--text-secondary, #ccc);
            margin: 0;
            overflow-x: auto;
            white-space: pre;
        }

        .log-details {
            max-width: 100%;
            overflow-x: auto;
        }

        .log-notes {
            background: var(--surface-primary, #0d0d0d);
            padding: 0.75rem;
            border-radius: 4px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', monospace;
            font-size: 0.875rem;
            color: var(--text-secondary, #ccc);
            margin: 0;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        /* Logs tab layout - flex container for logs + chat */
        .logs-tab-content {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 140px);
            position: relative;
        }

        .logs-tab-content .execution-logs-container {
            flex: 1;
            overflow-y: auto;
            padding-bottom: 100px; /* Space for fixed chat input */
            scrollbar-width: thin;
            scrollbar-color: transparent transparent;
        }

        .logs-tab-content .execution-logs-container::-webkit-scrollbar {
            width: 10px;
        }

        .logs-tab-content .execution-logs-container::-webkit-scrollbar-track {
            background: transparent;
        }

        .logs-tab-content .execution-logs-container::-webkit-scrollbar-thumb {
            background-color: transparent;
            border-radius: 999px;
        }

        .logs-tab-content .execution-logs-container:hover::-webkit-scrollbar-thumb {
            background-color: rgba(255, 255, 255, 0.08);
        }

        /* Chat input container - fixed at bottom */
        .logs-chat-container {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            border-top: 1px solid var(--border-color, #333);
            padding: 1rem;
            background: var(--surface-primary, #1e1e1e);
        }

        /* AI typing indicator */
        .ai-typing-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            /* padding: 0.75rem 0; */
            margin: 0.25rem 0 0.5rem;
            border-left: none;
            background: transparent;
            border-radius: 0;
            color: var(--text-secondary, #bdbdbd);
            font-size: 0.9rem;
        }

        .ai-typing-indicator .typing-dots {
            display: flex;
            gap: 4px;
        }

        .ai-typing-indicator .typing-dots span {
            width: 6px;
            height: 6px;
            background: var(--purple-accent, #8B5CF6);
            border-radius: 50%;
            animation: typingBounce 1.4s infinite ease-in-out;
        }

        .ai-typing-indicator .typing-dots span:nth-child(1) { animation-delay: 0s; }
        .ai-typing-indicator .typing-dots span:nth-child(2) { animation-delay: 0.2s; }
        .ai-typing-indicator .typing-dots span:nth-child(3) { animation-delay: 0.4s; }

        @keyframes typingBounce {
            0%, 80%, 100% { transform: translateY(0); opacity: 0.4; }
            40% { transform: translateY(-4px); opacity: 1; }
        }

        /* Stop execution button */
        .stop-execution-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            background: radial-gradient(circle at 30% 30%, #f87171, #dc2626);
            border: none;
            border-radius: 50%;
            color: #fff;
            font-size: 0.6rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        .stop-execution-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 14px rgba(248, 113, 113, 0.25);
        }

        .stop-execution-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .logs-chat-actions {
            display: flex;
            align-items: center;
            gap: 0.35rem;
        }

        .logs-chat-stop-btn {
            display: none;
        }

        .logs-chat-input-wrapper {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .logs-chat-field {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            background: var(--surface-secondary, #111111);
            border: 1px solid rgba(148, 163, 184, 0.25);
            border-radius: 12px;
            padding: 0.2rem 0.45rem 0.2rem 0.3rem;
        }

        .logs-chat-field:focus-within {
            border-color: rgba(139, 92, 246, 0.8);
            box-shadow: 0 0 0 1px rgba(139, 92, 246, 0.6);
        }

        .logs-chat-attach-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: transparent;
            border: none;
            color: var(--text-secondary, #a3a3a3);
            padding: 0.35rem;
            cursor: pointer;
            transition: color 0.2s, background 0.2s;
            border-radius: 50%;
        }

        .logs-chat-attach-btn:hover {
            color: var(--text-primary, #fff);
            background: rgba(255, 255, 255, 0.05);
        }

        .logs-chat-attachments {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .logs-chat-attachment {
            display: flex;
            align-items: center;
            gap: 0.375rem;
            background: var(--surface-secondary, #1a1a1a);
            border: 1px solid var(--border-color, #333);
            border-radius: 6px;
            padding: 0.25rem 0.5rem;
            font-size: 0.75rem;
            color: var(--text-secondary, #888);
        }

        .logs-chat-attachment .remove-attachment {
            cursor: pointer;
            color: var(--text-secondary, #888);
            padding: 0.125rem;
        }

        .logs-chat-attachment .remove-attachment:hover {
            color: var(--error-color, #ef4444);
        }

        .logs-chat-input {
            flex: 1;
            background: transparent;
            border: none;
            padding: 0.45rem 0.3rem 0.45rem 0.1rem;
            color: var(--text-primary, #fff);
            font-size: 0.9rem;
            resize: none;
            font-family: inherit;
            line-height: 1.4;
            min-height: 38px;
            max-height: 120px;
        }

        .logs-chat-input:focus {
            outline: none;
        }

        .logs-chat-input::placeholder {
            color: var(--text-secondary, #888);
        }

        .logs-chat-send-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: none;
            background: radial-gradient(circle at 30% 30%, #c084fc, #7c3aed);
            color: #fff;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        .logs-chat-send-btn:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 14px rgba(124, 58, 237, 0.35);
        }

        .logs-chat-send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .logs-chat-send-btn i {
            font-size: 0.675rem;
        }


        /* User message in logs - purple theme */
        .execution-log-entry.user-message {
            border-left: 3px solid var(--purple-accent, #8B5CF6);
            margin: 1rem 0;
            padding: 0.75rem 1rem;
            background: rgba(139, 92, 246, 0.05);
            border-radius: 0 8px 8px 0;
        }

        .execution-log-entry.user-message .log-header {
            cursor: default;
            padding: 0;
        }

        .execution-log-entry.user-message .log-explanation {
            white-space: pre-wrap;
            word-break: break-word;
            color: var(--text-primary, #fff);
        }

        .user-message-icon {
            color: var(--purple-accent, #8B5CF6);
            flex-shrink: 0;
        }

        /* AI response in logs - slightly different shade */
        .execution-log-entry.ai-response {
            border-left: 3px solid #34d399;
            margin: 1rem 0;
            padding: 0.75rem 1rem;
            background: rgba(167, 139, 250, 0.05);
            border-radius: 0 8px 8px 0;
        }

        .execution-log-entry.ai-response .log-header {
            cursor: default;
            padding: 0;
        }

        .ai-response-icon {
            color: #a78bfa;
            flex-shrink: 0;
        }

        .ai-response-content {
            margin-top: 0.75rem;
            color: var(--text-primary, #e6e6e6);
            font-family: inherit;
            font-size: 0.9rem;
            line-height: 1.65;
        }

        .ai-response-content p {
            margin: 0 0 0.75rem;
        }

        .ai-response-content ul,
        .ai-response-content ol {
            margin: 0.5rem 0 0.75rem 1.25rem;
            padding-left: 1.25rem;
        }

        .ai-response-content li {
            margin-bottom: 0.35rem;
        }

        .ai-response-content pre {
            background: #111826;
            border: 1px solid rgba(148, 163, 184, 0.25);
            border-radius: 6px;
            padding: 0.75rem 1rem;
            overflow-x: auto;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', monospace;
            font-size: 0.8rem;
            color: #e5e7eb;
            margin-bottom: 1rem;
        }

        .ai-response-content code {
            background: rgba(148, 163, 184, 0.15);
            padding: 0.2rem 0.35rem;
            border-radius: 4px;
            font-size: 0.82rem;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', monospace;
        }

        .ai-response-content blockquote {
            border-left: 4px solid rgba(167, 139, 250, 0.4);
            padding-left: 0.75rem;
            margin: 0.5rem 0 1rem;
            color: var(--text-secondary, #b4b4b4);
            font-style: italic;
        }

        /* Command entries - more spacing */
        .execution-log-entry:not(.user-message):not(.ai-response) {
            margin: 0.75rem 0;
        }

        /* Tasks styling */
        .tasks-list {
            padding: 0;
            list-style: none;
        }

        .task-item {
            display: flex;
            align-items: flex-start;
            padding: 0.625rem 0.5rem;
            gap: 0.75rem;
            border: none;
            background: transparent;
        }

        .task-checkbox {
            appearance: none;
            width: 18px;
            height: 18px;
            border: 1.5px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            cursor: pointer;
            position: relative;
            flex-shrink: 0;
            margin-top: 0.125rem;
            background-color: transparent;
            transition: all 0.2s;
        }

        .task-checkbox:hover {
            border-color: rgba(255, 255, 255, 0.5);
        }

        .task-checkbox:checked {
            background-color: transparent;
            border-color: #22c55e;
        }

        .task-checkbox:checked::after {
            content: '\f00c';
            font-family: 'Font Awesome 6 Free';
            font-weight: 900;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #22c55e;
            font-size: 10px;
        }

        .task-item.pending .task-checkbox {
            border-color: rgba(255, 255, 255, 0.3);
        }

        .task-item.success .task-checkbox,
        .task-item.completed .task-checkbox {
            background-color: transparent;
            border-color: #22c55e;
        }

        .task-item.success .task-checkbox::after,
        .task-item.completed .task-checkbox::after {
            content: '\f00c';
            font-family: 'Font Awesome 6 Free';
            font-weight: 900;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #22c55e;
            font-size: 10px;
        }

        .task-item.in_progress .task-checkbox {
            border-color: #f59e0b;
            background-color: transparent;
        }

        .task-item.in_progress .task-checkbox::after {
            content: '\f110';
            font-family: 'Font Awesome 6 Free';
            font-weight: 900;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #f59e0b;
            font-size: 10px;
        }

        .task-item.fail .task-checkbox,
        .task-item.failed .task-checkbox {
            border-color: #ef4444;
            background-color: transparent;
        }

        .task-item.fail .task-checkbox::after,
        .task-item.failed .task-checkbox::after {
            content: '\f00d';
            font-family: 'Font Awesome 6 Free';
            font-weight: 900;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ef4444;
            font-size: 10px;
        }

        .task-label {
            flex: 1;
            cursor: pointer;
            font-size: 0.875rem;
            line-height: 1.5;
            color: var(--text-primary, #fff);
        }

        .task-item.success .task-label,
        .task-item.completed .task-label {
            text-decoration: line-through;
            opacity: 0.6;
        }

        .task-description {
            display: block;
            color: var(--text-secondary, #aaa);
            font-size: 0.8125rem;
            margin-top: 0.25rem;
        }

        /* Markdown content styling */
        .markdown-content {
            line-height: 1.6;
            color: var(--text-primary, #fff);
        }

        .markdown-content h1,
        .markdown-content h2,
        .markdown-content h3,
        .markdown-content h4,
        .markdown-content h5,
        .markdown-content h6 {
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
            font-weight: 600;
            color: var(--text-primary, #fff);
        }

        .markdown-content h1 { font-size: 1.75rem; }
        .markdown-content h2 { font-size: 1.5rem; }
        .markdown-content h3 { font-size: 1.25rem; }
        .markdown-content h4 { font-size: 1.1rem; }
        .markdown-content h5 { font-size: 1rem; }
        .markdown-content h6 { font-size: 0.95rem; }

        .markdown-content p {
            margin-bottom: 1rem;
        }

        .markdown-content ul,
        .markdown-content ol {
            margin-bottom: 1rem;
            padding-left: 1.5rem;
        }

        .markdown-content li {
            margin-bottom: 0.5rem;
        }

        .markdown-content code {
            background: rgba(255, 255, 255, 0.1);
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', monospace;
            font-size: 0.875rem;
            color: #4EC9B0;
        }

        .markdown-content pre {
            background: rgba(0, 0, 0, 0.3);
            padding: 1rem;
            border-radius: 4px;
            overflow-x: auto;
            margin-bottom: 1rem;
        }

        .markdown-content pre code {
            background: none;
            padding: 0;
            color: var(--text-secondary, #ccc);
        }

        .markdown-content blockquote {
            border-left: 3px solid var(--accent-color, #4A90E2);
            padding-left: 1rem;
            margin-left: 0;
            color: var(--text-secondary, #aaa);
            font-style: italic;
        }

        .markdown-content table {
            border-collapse: collapse;
            margin: 1rem 0;
            width: 100%;
            overflow-x: auto;
        }

        .markdown-content table th,
        .markdown-content table td {
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 0.5rem 0.75rem;
            text-align: left;
        }

        .markdown-content table th {
            background: rgba(255, 255, 255, 0.05);
            font-weight: 600;
        }

        .markdown-content a {
            color: var(--accent-color, #4A90E2);
            text-decoration: none;
        }

        .markdown-content a:hover {
            text-decoration: underline;
        }

        .markdown-content hr {
            border: none;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            margin: 1.5rem 0;
        }

        .markdown-content strong {
            font-weight: 600;
        }

        .markdown-content em {
            font-style: italic;
        }

        /* Animation for status indicator */
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .tickets-filters {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: space-between;
            align-items: center;
        }

        .tickets-filters .filter-left {
            flex: 1;
            min-width: 240px;
        }

        .tickets-filters .filter-right {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            justify-content: flex-end;
        }

        .new-ticket-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.55rem 1rem;
            border-radius: 8px;
            font-weight: 600;
        }

        .new-ticket-btn[disabled] {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.65);
            display: none;
            align-items: flex-start;
            justify-content: center;
            z-index: 999;
            padding: 2rem 1rem;
            overflow-y: auto;
        }
        
        .modal-overlay.active {
            display: flex;
        }
        
        .modal-dialog {
            background: #111827;
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            width: 100%;
            max-width: 520px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.4);
            display: flex;
            flex-direction: column;
            max-height: 90vh;
            margin: auto;
        }

        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1.25rem 1.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        }

        .modal-body {
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            overflow-y: auto;
            max-height: calc(90vh - 155px);
        }

        .modal-body label {
            display: block;
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 0.35rem;
        }

        .modal-body input,
        .modal-body select,
        .modal-body textarea {
            width: 100%;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(17, 24, 39, 0.7);
            color: #fff;
            padding: 0.65rem 0.75rem;
            font-size: 0.95rem;
        }

        .modal-body textarea {
            resize: vertical;
            min-height: 120px;
        }

        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
            padding: 1rem 1.5rem 1.25rem;
            border-top: 1px solid rgba(255, 255, 255, 0.08);
            background: rgba(15, 23, 42, 0.95);
            position: sticky;
            bottom: 0;
        }

        .modal-close-btn {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.6);
            font-size: 1.25rem;
            cursor: pointer;
        }

        .modal-close-btn:hover {
            color: #fff;
        }

        .modal-checkbox {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.8);
        }

        .modal-checkbox input {
            width: auto;
        }

        .modal-error {
            background: rgba(239, 68, 68, 0.15);
            border: 1px solid rgba(239, 68, 68, 0.4);
            color: #f87171;
            padding: 0.5rem 0.75rem;
            border-radius: 8px;
            font-size: 0.85rem;
            display: none;
        }

        .attachment-preview-list {
            margin-top: 0.5rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .attachment-preview-empty {
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.85rem;
        }

        .attachment-chip {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0.75rem;
            border-radius: 8px;
            background: rgba(167, 139, 250, 0.1);
            border: 1px solid rgba(167, 139, 250, 0.3);
            font-size: 0.85rem;
            gap: 0.75rem;
        }

        .attachment-chip .meta {
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.6);
        }

        .attachment-chip button {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.6);
            cursor: pointer;
            padding: 0.15rem;
        }

        .attachment-chip button:hover {
            color: #fff;
        }

        .file-upload-hint {
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.5);
            margin-top: 0.35rem;
        }

        .ticket-attachments-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 0.75rem;
            margin-top: 0.75rem;
        }

        .ticket-attachment-card {
            display: flex;
            gap: 0.75rem;
            align-items: center;
            padding: 0.75rem;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            background: rgba(15, 23, 42, 0.6);
            text-decoration: none;
            color: inherit;
            transition: border-color 0.2s ease, transform 0.2s ease;
        }

        .ticket-attachment-card:hover {
            border-color: rgba(167, 139, 250, 0.6);
            transform: translateY(-1px);
        }

        .ticket-attachment-icon {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            background: rgba(167, 139, 250, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            color: #c4b5fd;
            font-size: 1rem;
        }

        .ticket-attachment-info .name {
            font-weight: 600;
            font-size: 0.9rem;
        }

        .ticket-attachment-info .meta {
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.6);
            margin-top: 0.15rem;
        }

        .modal-context {
            padding: 0.85rem 1rem;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        .modal-context-label {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 0.35rem;
        }

        .modal-context-value {
            font-weight: 600;
            color: #fff;
        }

        .modal-context-hint {
            margin-top: 0.25rem;
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.5);
        }
    </style>
</head>
<body data-theme="dark"
      data-user-authenticated="{% if user.is_authenticated %}true{% else %}false{% endif %}"
      data-model-key="{{ current_model_key|default:'gpt-5-mini' }}"
      data-sidebar-minimized="{% if sidebar_minimized %}true{% else %}false{% endif %}">
    <div class="app-container{% if sidebar_minimized %} sidebar-minimized{% endif %}">
        {% include 'includes/sidebar.html' with show_conversations=False %}

        <div class="main-content tickets-page">

            <div class="tickets-body">
                <!-- Filters Section -->
                <div class="tickets-filters">
                    <div class="filter-left">
                        <input type="text" class="filter-search" id="ticketSearch" placeholder="Search tickets..." onkeyup="filterTickets()">
                    </div>
                    <div class="filter-right">
                        {% if not current_project %}
                        <select class="filter-select" id="projectFilter" onchange="filterTickets()">
                            <option value="">All Projects</option>
                            {% for project in projects %}
                                <option value="{{ project.project_id }}">{{ project.name }}</option>
                            {% endfor %}
                        </select>
                        {% else %}
                        <input type="hidden" id="projectFilter" value="{{ current_project.project_id }}">
                        {% endif %}
                        <select class="filter-select" id="statusFilter" onchange="filterTickets()">
                            <option value="">All Statuses</option>
                            {% for status in statuses %}
                                <option value="{{ status }}">{{ status|title }}</option>
                            {% endfor %}
                        </select>
                        <select class="filter-select" id="priorityFilter" onchange="filterTickets()">
                            <option value="">All Priorities</option>
                            {% for priority in priorities %}
                                <option value="{{ priority }}">{{ priority }}</option>
                            {% endfor %}
                        </select>
                        <select class="filter-select" id="model-dropdown" style="min-width: 180px;">
                            {% if llm_model_config.providers %}
                                {% for provider_key, provider in llm_model_config.providers.items %}
                                    <optgroup label="{{ provider.label }}">
                                        {% for model in provider.models %}
                                            <option value="{{ model.key }}"
                                                {% if current_model_key == model.key %}
                                                    selected
                                                {% elif not current_model_key and forloop.parentloop.first and forloop.first %}
                                                    selected
                                                {% endif %}>
                                                {{ model.label }}
                                            </option>
                                        {% endfor %}
                                    </optgroup>
                                {% endfor %}
                            {% else %}
                                
                            {% endif %}
                        </select>
                        <button type="button"
                                class="btn btn-primary new-ticket-btn"
                                id="newTicketBtn"
                                {% if not projects and not current_project %}
                                    disabled
                                    title="Create a project first"
                                {% endif %}>
                            <i class="fas fa-plus"></i>
                            New Ticket
                        </button>
                    </div>
                </div>

                <!-- Tickets Table -->
                <div class="tickets-table-wrapper">
                    <table class="tickets-table" id="ticketsTable" {% if not tickets %}style="display: none;"{% endif %}>
                        <thead>
                            <tr>
                                <th>Ticket</th>
                                <th>Status</th>
                                <th>Priority</th>
                                <th>Queue</th>
                            </tr>
                        </thead>
                        <tbody id="ticketsTableBody">
                            {% if tickets %}
                                {% for ticket in tickets %}
                                    <tr class="ticket-row"
                                        data-ticket-id="{{ ticket.id }}"
                                        data-project-id="{{ ticket.project.project_id }}"
                                        data-status="{{ ticket.status }}"
                                        data-priority="{{ ticket.priority }}"
                                        data-name="{{ ticket.name|lower }}"
                                        data-description="{{ ticket.description|lower }}">
                                        <td onclick="viewTicketDetails({{ ticket.id }}, '{{ ticket.project.project_id }}')" style="cursor: pointer;">
                                            <div class="ticket-info">
                                                <div class="ticket-name">{{ ticket.name }}</div>
                                            </div>
                                        </td>
                                        <td>
                                            <select class="table-select status-select"
                                                    data-ticket-id="{{ ticket.id }}"
                                                    data-project-id="{{ ticket.project.project_id }}"
                                                    data-status="{{ ticket.status }}"
                                                    onchange="updateTicketFromTable(this, 'status')">
                                                <option value="open" {% if ticket.status == 'open' %}selected{% endif %}>Open</option>
                                                <option value="in_progress" {% if ticket.status == 'in_progress' %}selected{% endif %}>In Progress</option>
                                                <option value="done" {% if ticket.status == 'done' %}selected{% endif %}>Done</option>
                                                <option value="blocked" {% if ticket.status == 'blocked' %}selected{% endif %}>Blocked</option>
                                            </select>
                                        </td>
                                        <td>
                                            <select class="table-select priority-select"
                                                    data-ticket-id="{{ ticket.id }}"
                                                    data-project-id="{{ ticket.project.project_id }}"
                                                    data-priority="{{ ticket.priority }}"
                                                    onchange="updateTicketFromTable(this, 'priority')">
                                                <option value="Low" {% if ticket.priority == 'Low' %}selected{% endif %}>Low</option>
                                                <option value="Medium" {% if ticket.priority == 'Medium' %}selected{% endif %}>Medium</option>
                                                <option value="High" {% if ticket.priority == 'High' %}selected{% endif %}>High</option>
                                            </select>
                                        </td>
                                        <td>
                                            <div class="queue-status-cell"
                                                 data-ticket-id="{{ ticket.id }}"
                                                 data-project-id="{{ ticket.project.project_id }}"
                                                 data-queue-status="{{ ticket.queue_status }}">
                                                {% if ticket.queue_status == 'queued' %}
                                                    <span class="queue-badge queued">
                                                        <i class="fas fa-clock"></i> Queued
                                                    </span>
                                                    <button class="queue-cancel-btn" onclick="cancelFromQueue({{ ticket.id }}, '{{ ticket.project.project_id }}')" title="Remove from queue">
                                                        <i class="fas fa-times"></i>
                                                    </button>
                                                    <button class="queue-restart-btn" onclick="restartFromQueue({{ ticket.id }}, '{{ ticket.project.project_id }}')" title="Restart ticket">
                                                        <i class="fas fa-redo"></i>
                                                    </button>
                                                {% elif ticket.queue_status == 'executing' %}
                                                    <span class="queue-badge executing">
                                                        <i class="fas fa-spinner fa-spin"></i> Executing
                                                    </span>
                                                    <button class="queue-force-stop-btn" onclick="forceStopFromQueue({{ ticket.id }}, '{{ ticket.project.project_id }}')" title="Force stop (use if stuck)">
                                                        <i class="fas fa-stop"></i>
                                                    </button>
                                                    <button class="queue-restart-btn" onclick="restartFromQueue({{ ticket.id }}, '{{ ticket.project.project_id }}')" title="Force restart">
                                                        <i class="fas fa-redo"></i>
                                                    </button>
                                                {% else %}
                                                    <span class="queue-badge none">-</span>
                                                {% endif %}
                                            </div>
                                        </td>
                                    </tr>
                                {% endfor %}
                            {% endif %}
                        </tbody>
                    </table>
                    <div class="empty-state" id="ticketsEmptyState" {% if tickets %}style="display: none;"{% endif %}>
                        <div class="empty-state-icon">
                            <i class="fas fa-tasks"></i>
                        </div>
                        <h3 class="empty-state-title">No tickets yet</h3>
                        <div class="empty-state-text">
                            {% if current_project %}
                            Create tickets for {{ current_project.name }} to track work items.
                            {% else %}
                            Create tickets in your projects to track work items.
                            {% endif %}
                        </div>
                        {% if not current_project %}
                        <a href="{% url 'projects:project_list' %}" class="btn btn-primary">
                            <i class="fas fa-folder"></i> Go to Projects
                        </a>
                        {% endif %}
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Ticket Details Drawer -->
    <div id="ticketDrawerOverlay" class="drawer-overlay" onclick="handleOverlayClick()"></div>
    <div id="ticketDrawer" class="drawer">
        <div class="drawer-resize-handle" id="drawerResizeHandle"></div>
        <div class="drawer-header">
            <div class="drawer-header-left">
                <h3 class="drawer-title" id="drawerTicketTitle"></h3>
            </div>
            <div class="drawer-header-right">
                <div class="drawer-actions">
                    <button type="button" class="drawer-server-btn" id="restartServerBtn" onclick="restartDevServer()">
                        Restart Server
                    </button>
                    <button class="drawer-open-url-btn" onclick="openPreviewInNewTab()" id="openPreviewBtn" title="Preview not available yet" disabled>
                        <i class="fas fa-arrow-up-right-from-square"></i>
                    </button>
                    <button class="drawer-execute-btn" onclick="executeTicket()" id="executeTicketBtn">
                        <i class="fas fa-hammer"></i> Build Ticket
                    </button>
                </div>
                <button class="drawer-close" onclick="closeTicketDrawer()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
        </div>
        <div class="drawer-tabs">
            <button class="drawer-tab active" data-tab="details" onclick="switchDrawerTab('details')">
                <i class="fas fa-info-circle"></i> Details
            </button>
            <button class="drawer-tab" data-tab="logs" onclick="switchDrawerTab('logs')">
                <i class="fas fa-terminal"></i> Logs
            </button>
            <button class="drawer-tab" data-tab="tasks" onclick="switchDrawerTab('tasks')">
                <i class="fas fa-list-check"></i> Tasks
            </button>
            <button class="drawer-tab" data-tab="preview" onclick="switchDrawerTab('preview')">
                <i class="fas fa-desktop"></i> Preview
            </button>
        </div>
        <div class="drawer-body" id="drawerTicketBody">
            <!-- Ticket details will be loaded here -->
        </div>
    </div>

    <!-- New Ticket Modal -->
    <div class="modal-overlay" id="newTicketModal" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-header">
                <h3 style="margin: 0; font-size: 1.1rem;">Create Ticket</h3>
                <button type="button" class="modal-close-btn" id="closeNewTicketBtn" aria-label="Close modal">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            {% if projects %}
                <form id="newTicketForm">
                    <div class="modal-body">
                        <input type="hidden" id="newTicketProject">
                        <div class="modal-context" id="newTicketProjectDisplay">
                            <div class="modal-context-label">Project</div>
                            <div class="modal-context-value" id="newTicketProjectLabel">{% if current_project %}{{ current_project.name }}{% else %}---{% endif %}</div>
                            {% if not current_project %}
                            <div class="modal-context-hint">
                                Uses the project from the filters above. Switch the filter to create a ticket in another project.
                            </div>
                            {% endif %}
                        </div>
                        <div>
                            <label for="newTicketName">Ticket name</label>
                            <input type="text" id="newTicketName" maxlength="255" required placeholder="Add an informative title">
                        </div>
                        <div>
                            <label for="newTicketDescription">Description</label>
                            <textarea id="newTicketDescription" placeholder="What needs to be built?" required></textarea>
                        </div>
                        <div class="file-upload-field">
                            <label for="newTicketFiles">Attachments (optional)</label>
                            <input type="file"
                                   id="newTicketFiles"
                                   multiple
                                   accept="image/*,.pdf,.csv,.txt,.md,.doc,.docx,.ppt,.pptx,.xls,.xlsx,.json,.zip,.rar,.7z,.mp4,.mov,.mp3">
                            <div class="file-upload-hint">
                                Attach screenshots, specs, or reference files. You can add more later from the ticket drawer.
                            </div>
                            <div id="newTicketFileList" class="attachment-preview-list">
                                <p class="attachment-preview-empty">No files selected.</p>
                            </div>
                        </div>
                        <div>
                            <label for="newTicketStatus">Status</label>
                            <select id="newTicketStatus">
                                <option value="open" selected>Open</option>
                                <option value="in_progress">In Progress</option>
                                <option value="done">Done</option>
                                <option value="blocked">Blocked</option>
                            </select>
                        </div>
                        <div>
                            <label for="newTicketPriority">Priority</label>
                            <select id="newTicketPriority">
                                <option value="High">High</option>
                                <option value="Medium" selected>Medium</option>
                                <option value="Low">Low</option>
                            </select>
                        </div>
                        <div>
                            <label for="newTicketRole">Role</label>
                            <select id="newTicketRole">
                                <option value="user" selected>User</option>
                                <option value="agent">Agent</option>
                            </select>
                        </div>
                        <div>
                            <label for="newTicketComplexity">Complexity</label>
                            <select id="newTicketComplexity">
                                <option value="simple">Simple</option>
                                <option value="medium" selected>Medium</option>
                                <option value="complex">Complex</option>
                            </select>
                        </div>
                        <label class="modal-checkbox" for="newTicketRequiresWorktree">
                            <input type="checkbox" id="newTicketRequiresWorktree" checked>
                            Requires worktree
                        </label>
                        <div class="modal-error" id="newTicketError"></div>
                    </div>
                    <div class="modal-actions">
                        <button type="button" class="btn btn-secondary" id="cancelNewTicketBtn">Cancel</button>
                        <button type="submit" class="btn btn-primary" id="createTicketSubmit">
                            <i class="fas fa-plus"></i>
                            Create Ticket
                        </button>
                    </div>
                </form>
            {% else %}
                <div class="modal-body">
                    <p style="margin: 0;">You need a project before you can add tickets. Create a project and try again.</p>
                </div>
                <div class="modal-actions">
                    <a href="{% url 'projects:create_project' %}" class="btn btn-primary">Create Project</a>
                </div>
            {% endif %}
        </div>
    </div>

    <script src="/static/js/sidebar.js"></script>
    <script src="/static/js/marked.min.js"></script>
    <script src="/static/js/model-handler.js"></script>
    <script>
        // Verify marked.js loaded
        if (typeof marked === 'undefined') {
            console.error('marked.js failed to load!');
        } else {
            console.log('marked.js loaded successfully!');
            // Configure marked for GitHub Flavored Markdown
            marked.setOptions({
                gfm: true,
                breaks: true,
                headerIds: true,
                mangle: false
            });
        }
    </script>
    <script>
        // Current project context (set by server when viewing project-scoped tickets)
        const currentProject = {% if current_project %}{ id: '{{ current_project.project_id }}', name: '{{ current_project.name|escapejs }}' }{% else %}null{% endif %};

        // Filter tickets function
        function filterTickets() {
            const searchTerm = document.getElementById('ticketSearch').value.toLowerCase();
            const projectFilter = document.getElementById('projectFilter').value;
            const statusFilter = document.getElementById('statusFilter').value;
            const priorityFilter = document.getElementById('priorityFilter').value;

            const rows = document.querySelectorAll('.ticket-row');
            let visibleCount = 0;

            rows.forEach(row => {
                const name = row.dataset.name || '';
                const description = row.dataset.description || '';
                const projectId = row.dataset.projectId || '';
                const status = row.dataset.status || '';
                const priority = row.dataset.priority || '';

                const matchesSearch = !searchTerm ||
                    name.includes(searchTerm) ||
                    description.includes(searchTerm);
                const matchesProject = !projectFilter || projectId === projectFilter;
                const matchesStatus = !statusFilter || status === statusFilter;
                const matchesPriority = !priorityFilter || priority === priorityFilter;

                if (matchesSearch && matchesProject && matchesStatus && matchesPriority) {
                    row.style.display = '';
                    visibleCount++;
                } else {
                    row.style.display = 'none';
                }
            });

            // Show/hide empty state if needed
            const table = document.getElementById('ticketsTable');
            if (table) {
                table.style.display = visibleCount > 0 ? 'table' : 'none';
            }
            toggleTicketsEmptyState(visibleCount > 0);
        }

        function toggleTicketsEmptyState(hasTickets) {
            const emptyState = document.getElementById('ticketsEmptyState');
            const table = document.getElementById('ticketsTable');
            if (emptyState) {
                emptyState.style.display = hasTickets ? 'none' : '';
            }
            if (table && hasTickets) {
                table.style.display = 'table';
            }
        }

        function addTicketRow(ticket) {
            if (!ticket) return;
            const tbody = document.getElementById('ticketsTableBody');
            if (!tbody) return;

            toggleTicketsEmptyState(true);

            const row = document.createElement('tr');
            row.className = 'ticket-row';
            row.dataset.ticketId = ticket.id;
            row.dataset.projectId = ticket.project_id || '';
            row.dataset.status = ticket.status || 'open';
            row.dataset.priority = ticket.priority || 'Medium';
            row.dataset.name = (ticket.name || '').toLowerCase();
            row.dataset.description = (ticket.description || '').toLowerCase();

            const ticketCell = document.createElement('td');
            ticketCell.style.cursor = 'pointer';
            ticketCell.addEventListener('click', () => viewTicketDetails(ticket.id, ticket.project_id));
            ticketCell.innerHTML = `
                <div class="ticket-info">
                    <div class="ticket-name">${escapeHtml(ticket.name)}</div>
                </div>
            `;

            const statusCell = document.createElement('td');
            const statusSelect = document.createElement('select');
            statusSelect.className = 'table-select status-select';
            statusSelect.dataset.ticketId = ticket.id;
            statusSelect.dataset.projectId = ticket.project_id || '';
            statusSelect.dataset.status = ticket.status || 'open';
            [
                { value: 'open', label: 'Open' },
                { value: 'in_progress', label: 'In Progress' },
                { value: 'done', label: 'Done' },
                { value: 'blocked', label: 'Blocked' }
            ].forEach(option => {
                const opt = document.createElement('option');
                opt.value = option.value;
                opt.textContent = option.label;
                if (option.value === (ticket.status || 'open')) {
                    opt.selected = true;
                }
                statusSelect.appendChild(opt);
            });
            statusSelect.addEventListener('change', function() {
                updateTicketFromTable(this, 'status');
            });
            statusCell.appendChild(statusSelect);

            const priorityCell = document.createElement('td');
            const prioritySelect = document.createElement('select');
            prioritySelect.className = 'table-select priority-select';
            prioritySelect.dataset.ticketId = ticket.id;
            prioritySelect.dataset.projectId = ticket.project_id || '';
            prioritySelect.dataset.priority = ticket.priority || 'Medium';
            [
                { value: 'Low', label: 'Low' },
                { value: 'Medium', label: 'Medium' },
                { value: 'High', label: 'High' }
            ].forEach(option => {
                const opt = document.createElement('option');
                opt.value = option.value;
                opt.textContent = option.label;
                if (option.value === (ticket.priority || 'Medium')) {
                    opt.selected = true;
                }
                prioritySelect.appendChild(opt);
            });
            prioritySelect.addEventListener('change', function() {
                updateTicketFromTable(this, 'priority');
            });
            priorityCell.appendChild(prioritySelect);

            // Queue status cell
            const queueCell = document.createElement('td');
            const queueDiv = document.createElement('div');
            queueDiv.className = 'queue-status-cell';
            queueDiv.dataset.ticketId = ticket.id;
            queueDiv.dataset.projectId = ticket.project_id || '';
            queueDiv.dataset.queueStatus = ticket.queue_status || 'none';
            queueDiv.innerHTML = '<span class="queue-badge none">-</span>';
            queueCell.appendChild(queueDiv);

            row.appendChild(ticketCell);
            row.appendChild(statusCell);
            row.appendChild(priorityCell);
            row.appendChild(queueCell);
            tbody.prepend(row);

            filterTickets();
        }

        const newTicketModal = document.getElementById('newTicketModal');
        const newTicketForm = document.getElementById('newTicketForm');
        const newTicketProjectInput = document.getElementById('newTicketProject');
        const newTicketProjectLabel = document.getElementById('newTicketProjectLabel');
        const newTicketProjectDisplay = document.getElementById('newTicketProjectDisplay');
        const newTicketNameInput = document.getElementById('newTicketName');
        const newTicketDescriptionInput = document.getElementById('newTicketDescription');
        const newTicketStatusSelect = document.getElementById('newTicketStatus');
        const newTicketPrioritySelect = document.getElementById('newTicketPriority');
        const newTicketRoleSelect = document.getElementById('newTicketRole');
        const newTicketComplexitySelect = document.getElementById('newTicketComplexity');
        const newTicketRequiresWorktree = document.getElementById('newTicketRequiresWorktree');
        const newTicketFileInput = document.getElementById('newTicketFiles');
        const newTicketFileList = document.getElementById('newTicketFileList');
        let newTicketFiles = [];
        const newTicketError = document.getElementById('newTicketError');
        const newTicketBtn = document.getElementById('newTicketBtn');
        const cancelNewTicketBtn = document.getElementById('cancelNewTicketBtn');
        const closeNewTicketBtn = document.getElementById('closeNewTicketBtn');
        const createTicketSubmit = document.getElementById('createTicketSubmit');

        function resolveProjectContextFromFilter() {
            // If we have a current project context, use it
            if (currentProject) {
                return currentProject;
            }

            const projectFilter = document.getElementById('projectFilter');
            if (!projectFilter) return null;

            // For hidden input (when current_project is set), just use the value
            if (projectFilter.type === 'hidden') {
                return currentProject;
            }

            let projectOption = null;
            if (projectFilter.value) {
                projectOption = projectFilter.options[projectFilter.selectedIndex];
            } else {
                projectOption = Array.from(projectFilter.options).find(opt => opt.value);
            }

            if (projectOption && projectOption.value) {
                return {
                    id: projectOption.value,
                    name: projectOption.textContent.trim()
                };
            }
            return null;
        }

        function setModalProjectFromFilter() {
            if (!newTicketProjectInput) return false;
            const context = resolveProjectContextFromFilter();
            if (context) {
                newTicketProjectInput.value = context.id;
                if (newTicketProjectLabel) {
                    newTicketProjectLabel.textContent = context.name;
                }
                return true;
            }

            newTicketProjectInput.value = '';
            if (newTicketProjectLabel) {
                newTicketProjectLabel.textContent = 'Select a project first';
            }
            return false;
        }

        function openNewTicketModal() {
            if (!newTicketModal) return;
            const hasProject = setModalProjectFromFilter();
            if (!hasProject) {
                showNewTicketError('Select a project from the filters before creating a ticket.');
                if (createTicketSubmit) {
                    createTicketSubmit.disabled = true;
                }
            } else {
                showNewTicketError('');
                if (createTicketSubmit) {
                    createTicketSubmit.disabled = false;
                }
            }
            newTicketModal.classList.add('active');
            if (newTicketNameInput) {
                newTicketNameInput.focus();
            }
        }

        function closeNewTicketModal() {
            if (!newTicketModal) return;
            newTicketModal.classList.remove('active');
            resetNewTicketForm();
        }

        function resetNewTicketForm() {
            if (!newTicketForm) return;
            newTicketForm.reset();
            showNewTicketError('');
            if (newTicketStatusSelect) newTicketStatusSelect.value = 'open';
            if (newTicketPrioritySelect) newTicketPrioritySelect.value = 'Medium';
            if (newTicketRoleSelect) newTicketRoleSelect.value = 'user';
            if (newTicketComplexitySelect) newTicketComplexitySelect.value = 'medium';
            if (newTicketRequiresWorktree) newTicketRequiresWorktree.checked = true;
            setModalProjectFromFilter();
            newTicketFiles = [];
            if (newTicketFileInput) {
                newTicketFileInput.value = '';
            }
            renderNewTicketFiles();
        }

        function showNewTicketError(message) {
            if (!newTicketError) return;
            if (message) {
                newTicketError.textContent = message;
                newTicketError.style.display = 'block';
            } else {
                newTicketError.textContent = '';
                newTicketError.style.display = 'none';
            }
        }

        function renderNewTicketFiles() {
            if (!newTicketFileList) return;
            if (!newTicketFiles.length) {
                newTicketFileList.innerHTML = '<p class="attachment-preview-empty">No files selected.</p>';
                return;
            }

            newTicketFileList.innerHTML = newTicketFiles.map((file, index) => `
                <div class="attachment-chip">
                    <div>
                        <div>${escapeHtml(file.name)}</div>
                        <div class="meta">${formatFileSizeHuman(file.size)}</div>
                    </div>
                    <button type="button" class="chip-remove" data-index="${index}" aria-label="Remove ${escapeHtml(file.name)}">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            `).join('');

            newTicketFileList.querySelectorAll('.chip-remove').forEach(btn => {
                btn.addEventListener('click', () => {
                    const idx = parseInt(btn.dataset.index, 10);
                    removeNewTicketFile(idx);
                });
            });
        }

        function removeNewTicketFile(index) {
            if (index < 0 || index >= newTicketFiles.length) {
                return;
            }
            newTicketFiles.splice(index, 1);
            renderNewTicketFiles();
        }

        function handleNewTicketFileChange(event) {
            const files = Array.from(event.target.files || []);
            if (!files.length) return;

            files.forEach(file => {
                const fingerprint = `${file.name}-${file.size}-${file.lastModified}`;
                const exists = newTicketFiles.some(existing => `${existing.name}-${existing.size}-${existing.lastModified}` === fingerprint);
                if (!exists) {
                    newTicketFiles.push(file);
                }
            });

            if (newTicketFileInput) {
                newTicketFileInput.value = '';
            }
            renderNewTicketFiles();
        }

        async function handleNewTicketSubmit(event) {
            event.preventDefault();
            if (!newTicketProjectInput) return;

            const projectId = newTicketProjectInput.value;
            if (!projectId) {
                showNewTicketError('Select a project from the filters before creating a ticket.');
                return;
            }

            const name = (newTicketNameInput?.value || '').trim();
            const description = (newTicketDescriptionInput?.value || '').trim();

            if (!name || !description) {
                showNewTicketError('Name and description are required.');
                return;
            }

            const payload = {
                name,
                description,
                status: newTicketStatusSelect ? newTicketStatusSelect.value : 'open',
                priority: newTicketPrioritySelect ? newTicketPrioritySelect.value : 'Medium',
                role: newTicketRoleSelect ? newTicketRoleSelect.value : 'user',
                complexity: newTicketComplexitySelect ? newTicketComplexitySelect.value : 'medium',
                requires_worktree: newTicketRequiresWorktree ? newTicketRequiresWorktree.checked : true,
            };

            const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]');
            if (!csrfToken) {
                showNewTicketError('Missing CSRF token.');
                return;
            }

            showNewTicketError('');
            const originalButtonText = createTicketSubmit ? createTicketSubmit.innerHTML : '';
            if (createTicketSubmit) {
                createTicketSubmit.disabled = true;
                createTicketSubmit.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Creating...';
            }

            try {
                const response = await fetch(`/projects/${projectId}/api/checklist/create/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken.value
                    },
                    body: JSON.stringify(payload)
                });

                const data = await response.json();
                if (response.ok && data.success) {
                    const createdTicket = data.ticket || {};
                    addTicketRow(createdTicket);

                    if (newTicketFiles.length > 0) {
                        try {
                            await uploadTicketAttachments(projectId, createdTicket.id, newTicketFiles);
                        } catch (uploadError) {
                            console.error('Attachment upload failed:', uploadError);
                            alert('Ticket created, but attachments failed to upload. Please retry from the ticket drawer.');
                        }
                    }

                    closeNewTicketModal();
                } else {
                    showNewTicketError(data.error || 'Failed to create ticket');
                }
            } catch (error) {
                console.error('Error creating ticket:', error);
                showNewTicketError('Network error occurred while creating ticket.');
            } finally {
                if (createTicketSubmit) {
                    createTicketSubmit.disabled = false;
                    createTicketSubmit.innerHTML = originalButtonText || '<i class="fas fa-plus"></i> Create Ticket';
                }
            }
        }

        async function uploadTicketAttachments(projectId, ticketId, files) {
            if (!files || !files.length) return [];

            const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]');
            if (!csrfToken) {
                throw new Error('Missing CSRF token.');
            }

            const formData = new FormData();
            files.forEach(file => formData.append('files', file));

            const response = await fetch(`/projects/${projectId}/api/tickets/${ticketId}/attachments/`, {
                method: 'POST',
                headers: {
                    'X-CSRFToken': csrfToken.value
                },
                body: formData
            });

            const data = await response.json();
            if (!response.ok || !data.success) {
                throw new Error(data.error || 'Unable to upload attachments');
            }
            return data.attachments || [];
        }

        if (newTicketBtn && newTicketForm) {
            newTicketBtn.addEventListener('click', openNewTicketModal);
        }
        if (cancelNewTicketBtn) {
            cancelNewTicketBtn.addEventListener('click', closeNewTicketModal);
        }
        if (closeNewTicketBtn) {
            closeNewTicketBtn.addEventListener('click', closeNewTicketModal);
        }
        if (newTicketModal) {
            newTicketModal.addEventListener('click', (event) => {
                if (event.target === newTicketModal) {
                    closeNewTicketModal();
                }
            });
        }
        if (newTicketForm) {
            newTicketForm.addEventListener('submit', handleNewTicketSubmit);
        }
        if (newTicketFileInput) {
            newTicketFileInput.addEventListener('change', handleNewTicketFileChange);
        }
        renderNewTicketFiles();
        setModalProjectFromFilter();
        const projectFilterElement = document.getElementById('projectFilter');
        if (projectFilterElement) {
            projectFilterElement.addEventListener('change', () => {
                const hasProject = setModalProjectFromFilter();
                if (newTicketModal && newTicketModal.classList.contains('active')) {
                    if (!hasProject && createTicketSubmit) {
                        createTicketSubmit.disabled = true;
                        showNewTicketError('Select a project from the filters before creating a ticket.');
                    } else if (createTicketSubmit) {
                        createTicketSubmit.disabled = false;
                        showNewTicketError('');
                    }
                }
            });
        }

        // View ticket details
        async function viewTicketDetails(ticketId, projectId) {
            console.log('viewTicketDetails called:', {ticketId, projectId});
            try {
                const url = `/projects/${projectId}/api/checklist/`;
                console.log('Fetching from:', url);
                const response = await fetch(url);
                console.log('Response status:', response.status);
                const data = await response.json();
                console.log('Response data:', data);

                // Handle both response formats: {success, checklist} and {tickets}
                const ticketsList = data.tickets || data.checklist || [];
                console.log('Tickets list:', ticketsList);

                const ticket = ticketsList.find(t => t.id === ticketId);
                console.log('Found ticket:', ticket);

                if (ticket) {
                    // Add project_id to ticket if it doesn't exist
                    if (!ticket.project_id) {
                        ticket.project_id = projectId;
                    }
                    if (!Array.isArray(ticket.attachments)) {
                        ticket.attachments = [];
                    }
                    showTicketModal(ticket);
                } else {
                    console.error('Ticket not found in list');
                    alert('Ticket not found');
                }
            } catch (error) {
                console.error('Error loading ticket details:', error);
                alert('Error loading ticket details: ' + error.message);
            }
        }

        let currentTicket = null;
        let currentProjectId = null;
        let currentTab = 'details';
        let ticketLogsWebSocket = null;
        let reconnectAttempts = 0;
        let isAiProcessing = false;
        const MAX_RECONNECT_ATTEMPTS = 5;

        // WebSocket functions for real-time log updates
        function connectTicketLogsWebSocket(ticketId) {
            // Close existing connection if any
            disconnectTicketLogsWebSocket();

            try {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}/ws/tickets/${ticketId}/logs/`;

                console.log(`Connecting to ticket logs WebSocket: ${wsUrl}`);
                ticketLogsWebSocket = new WebSocket(wsUrl);

                ticketLogsWebSocket.onopen = function() {
                    console.log(`Connected to ticket logs WebSocket for ticket ${ticketId}`);
                    reconnectAttempts = 0;
                };

                ticketLogsWebSocket.onmessage = function(event) {
                    const data = JSON.parse(event.data);
                    console.log('Received WebSocket message:', data);

                    if (data.type === 'log_created') {
                        // Add the new log to the UI
                        handleNewLog(data.log);
                    } else if (data.type === 'status_changed') {
                        // Handle ticket status change
                        handleStatusChange(data.status, data.ticket_id);
                    }
                };

                ticketLogsWebSocket.onerror = function(error) {
                    console.error('WebSocket error:', error);
                };

                ticketLogsWebSocket.onclose = function(event) {
                    console.log('WebSocket closed:', event.code, event.reason);

                    // Try to reconnect if we're still viewing the logs tab
                    if (currentTab === 'logs' && currentTicket && currentTicket.id === ticketId) {
                        if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                            reconnectAttempts++;
                            const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), 30000);
                            console.log(`Attempting to reconnect in ${delay}ms (attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`);
                            setTimeout(() => {
                                if (currentTab === 'logs' && currentTicket && currentTicket.id === ticketId) {
                                    connectTicketLogsWebSocket(ticketId);
                                }
                            }, delay);
                        }
                    }
                };
            } catch (error) {
                console.error('Error creating WebSocket connection:', error);
            }
        }

        function disconnectTicketLogsWebSocket() {
            if (ticketLogsWebSocket) {
                console.log('Closing ticket logs WebSocket');
                ticketLogsWebSocket.close();
                ticketLogsWebSocket = null;
            }
        }

        // Render a log entry based on its type
        function renderLogEntry(log, index) {
            const logType = log.log_type || 'command';
            const timestamp = formatDate(log.created_at);

            if (logType === 'user_message') {
                // User message - purple theme
                return `
                    <div class="execution-log-entry user-message" data-cmd-index="${index}" data-log-id="${log.id}" data-log-type="user_message">
                        <div class="log-header">
                            <div style="display: flex; align-items: flex-start; gap: 0.625rem; flex: 1;">
                                <i class="fas fa-user user-message-icon" style="font-size: 0.875rem; margin-top: 3px;"></i>
                                <div>
                                    <span style="color: #8B5CF6; font-weight: 500; font-size: 0.8rem;">You</span>
                                    <div class="log-explanation" style="margin-top: 0.25rem;">${escapeHtml(log.command)}</div>
                                </div>
                            </div>
                            <span class="log-timestamp" style="white-space: nowrap; margin-left: 1rem; align-self: flex-start;">${timestamp}</span>
                        </div>
                    </div>
                `;
            } else if (logType === 'ai_response') {
                // AI response - show full message with markdown support
                const fullResponse = log.output || log.command || '';
                const renderedResponse = renderMarkdown(fullResponse);
                return `
                    <div class="execution-log-entry ai-response" data-cmd-index="${index}" data-log-id="${log.id}" data-log-type="ai_response">
                        <div class="log-header">
                            <div style="display: flex; align-items: flex-start; gap: 0.625rem; flex: 1;">
                                <span style="color: #a78bfa; font-weight: 500; font-size: 0.8rem;">ðŸš€ Agent</span>
                            </div>
                            <span class="log-timestamp" style="white-space: nowrap; margin-left: 1rem;">${timestamp}</span>
                        </div>
                        <div class="ai-response-content">${renderedResponse}</div>
                    </div>
                `;
            } else {
                // Command - default collapsible entry
                const explanation = log.explanation || 'No explanation provided';
                return `
                    <div class="execution-log-entry collapsed" data-cmd-index="${index}" data-log-id="${log.id}" data-log-type="command">
                        <div class="log-header" onclick="toggleCommandExpand('${index}')">
                            <div style="display: flex; align-items: center; gap: 0.5rem; flex: 1; overflow: hidden;">
                                <i class="fas fa-chevron-right expand-icon" style="font-size: 0.75rem; transition: transform 0.2s;"></i>
                                <span class="log-explanation" style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${escapeHtml(explanation)}</span>
                            </div>
                            <span class="log-timestamp" style="white-space: nowrap; margin-left: 1rem;">${timestamp}</span>
                        </div>
                        <div class="log-details" style="display: none;">
                            <pre class="log-command">${escapeHtml(log.command)}</pre>
                            ${log.output ? `<pre class="log-output">${escapeHtml(log.output)}</pre>` : '<p style="color: var(--text-secondary); font-style: italic; margin-top: 0.5rem; font-size: 0.875rem;">No output</p>'}
                        </div>
                    </div>
                `;
            }
        }

        // Scroll logs container to bottom to show latest logs
        function scrollLogsToBottom() {
            const logsContainer = document.getElementById('executionLogsContainer');
            if (logsContainer) {
                // Use requestAnimationFrame to ensure DOM is updated
                requestAnimationFrame(() => {
                    logsContainer.scrollTop = logsContainer.scrollHeight;
                });
            }
        }

        // Store pending file attachments for chat
        let logsChatAttachments = [];

        // Handle file selection for chat attachments
        function handleLogsChatFileSelect(event) {
            const files = Array.from(event.target.files);
            files.forEach(file => {
                // Prevent duplicates
                if (!logsChatAttachments.find(f => f.name === file.name && f.size === file.size)) {
                    logsChatAttachments.push(file);
                }
            });
            renderLogsChatAttachments();
            // Reset file input
            event.target.value = '';
        }

        // Render attachment previews
        function renderLogsChatAttachments() {
            const container = document.getElementById('logsChatAttachments');
            if (!container) return;

            if (logsChatAttachments.length === 0) {
                container.innerHTML = '';
                return;
            }

            container.innerHTML = logsChatAttachments.map((file, index) => `
                <div class="logs-chat-attachment">
                    <i class="fas ${getFileIcon(file.name)}"></i>
                    <span>${escapeHtml(truncateFilename(file.name, 20))}</span>
                    <span class="remove-attachment" onclick="removeLogsChatAttachment(${index})" title="Remove">
                        <i class="fas fa-times"></i>
                    </span>
                </div>
            `).join('');
        }

        // Get appropriate icon for file type
        function getFileIcon(filename) {
            const ext = filename.split('.').pop().toLowerCase();
            const icons = {
                'pdf': 'fa-file-pdf',
                'doc': 'fa-file-word', 'docx': 'fa-file-word',
                'xls': 'fa-file-excel', 'xlsx': 'fa-file-excel',
                'png': 'fa-file-image', 'jpg': 'fa-file-image', 'jpeg': 'fa-file-image', 'gif': 'fa-file-image', 'svg': 'fa-file-image',
                'zip': 'fa-file-archive', 'rar': 'fa-file-archive', 'tar': 'fa-file-archive', 'gz': 'fa-file-archive',
                'js': 'fa-file-code', 'ts': 'fa-file-code', 'py': 'fa-file-code', 'html': 'fa-file-code', 'css': 'fa-file-code', 'json': 'fa-file-code',
                'txt': 'fa-file-alt', 'md': 'fa-file-alt',
            };
            return icons[ext] || 'fa-file';
        }

        // Truncate filename for display
        function truncateFilename(name, maxLen) {
            if (name.length <= maxLen) return name;
            const ext = name.split('.').pop();
            const base = name.slice(0, name.length - ext.length - 1);
            const truncatedBase = base.slice(0, maxLen - ext.length - 4) + '...';
            return truncatedBase + '.' + ext;
        }

        // Remove an attachment
        function removeLogsChatAttachment(index) {
            logsChatAttachments.splice(index, 1);
            renderLogsChatAttachments();
        }

        // Clear all attachments
        function clearLogsChatAttachments() {
            logsChatAttachments = [];
            renderLogsChatAttachments();
        }

        // Handle keydown in chat input (Enter to send, Shift+Enter for newline)
        function handleLogsChatKeydown(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendLogsChatMessage();
            }
        }

        // Send chat message to continue ticket execution
        async function sendLogsChatMessage() {
            const input = document.getElementById('logsChatInput');
            const sendBtn = document.getElementById('logsChatSendBtn');
            const attachBtn = document.querySelector('.logs-chat-attach-btn');
            const message = input?.value?.trim();
            const hasAttachments = logsChatAttachments.length > 0;

            // Need either message or attachments to send
            if ((!message && !hasAttachments) || !currentTicket || !currentProjectId) {
                return;
            }

            // Disable inputs while sending
            input.disabled = true;
            sendBtn.disabled = true;
            if (attachBtn) attachBtn.disabled = true;
            const originalBtnHtml = sendBtn.innerHTML;
            sendBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';

            try {
                // User message will be added via WebSocket after it's saved to database
                // Send the message to the backend API using FormData for file support
                const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]')?.value;
                if (!csrfToken) {
                    throw new Error('CSRF token not found. Please refresh the page.');
                }

                const formData = new FormData();
                formData.append('message', message || '');
                formData.append('project_id', currentProjectId);

                // Add attachments
                logsChatAttachments.forEach((file, index) => {
                    formData.append('attachments', file);
                });

                const response = await fetch(`/api/v1/project-tickets/${currentTicket.id}/chat/`, {
                    method: 'POST',
                    headers: {
                        'X-CSRFToken': csrfToken
                    },
                    body: formData
                });

                const data = await response.json();

                if (!response.ok) {
                    throw new Error(data.error || 'Failed to send message');
                }

                // Clear input and attachments on success
                input.value = '';
                clearLogsChatAttachments();

                // Show AI typing indicator
                showAiTypingIndicator();

                // Show success feedback
                console.log('Chat message sent successfully:', data);

            } catch (error) {
                console.error('Error sending chat message:', error);
                // Show error notification
                alert('Failed to send message: ' + error.message);
                // Hide typing indicator on error
                hideAiTypingIndicator();
            } finally {
                // Re-enable inputs
                input.disabled = false;
                sendBtn.disabled = false;
                if (attachBtn) attachBtn.disabled = false;
                sendBtn.innerHTML = originalBtnHtml;
                input.focus();
            }
        }

        // Show AI typing indicator
        function showAiTypingIndicator() {
            const indicatorSlot = document.getElementById('aiTypingIndicatorSlot');
            if (!indicatorSlot) return;

            // Remove existing indicator if any
            hideAiTypingIndicator();

            indicatorSlot.innerHTML = `
                <div class="ai-typing-indicator" id="aiTypingIndicator">
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <span>ðŸš€ Agent is workingâ€¦</span>
                        <div class="typing-dots">
                            <span></span>
                            <span></span>
                            <span></span>
                        </div>
                    </div>
                </div>
            `;
            setAiProcessingState(true);
        }

        // Hide AI typing indicator
        function hideAiTypingIndicator() {
            const indicator = document.getElementById('aiTypingIndicator');
            if (indicator) {
                indicator.remove();
                const slot = document.getElementById('aiTypingIndicatorSlot');
                if (slot) {
                    slot.innerHTML = '';
                }
            }
            setAiProcessingState(false);
        }

        // Stop/interrupt AI execution
        async function stopExecution(event = null) {
            if (!currentTicket) return;

            const stopBtn = event?.currentTarget || document.getElementById('logsChatStopBtn');
            const originalBtnHtml = stopBtn ? stopBtn.innerHTML : null;
            if (stopBtn) {
                stopBtn.disabled = true;
                stopBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Stopping...';
            }

            try {
                const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]')?.value;
                const response = await fetch(`/api/v1/project-tickets/${currentTicket.id}/stop/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    }
                });

                const data = await response.json();
                if (response.ok) {
                    console.log('Stop request sent:', data);
                    // Hide typing indicator
                    hideAiTypingIndicator();
                } else {
                    console.error('Failed to stop:', data);
                    alert('Failed to stop: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error stopping execution:', error);
                alert('Failed to stop execution');
            } finally {
                if (stopBtn) {
                    stopBtn.disabled = false;
                    stopBtn.innerHTML = originalBtnHtml;
                }
            }
        }
        function updateSendStopButtons() {
            const sendBtn = document.getElementById('logsChatSendBtn');
            const stopBtn = document.getElementById('logsChatStopBtn');
            if (!sendBtn || !stopBtn) return;

            if (isAiProcessing) {
                sendBtn.style.display = 'none';
                stopBtn.style.display = 'inline-flex';
            } else {
                sendBtn.style.display = 'inline-flex';
                stopBtn.style.display = 'none';
            }
        }

        function setAiProcessingState(value) {
            isAiProcessing = value;
            updateSendStopButtons();
        }

        // Store pending logs when not on logs tab
        let pendingLogs = [];

        function handleNewLog(log) {
            console.log('Handling new log:', log);

            // Hide typing indicator when AI response arrives
            if (log.log_type === 'ai_response') {
                hideAiTypingIndicator();
            }

            // Find the logs container
            const logsContainer = document.querySelector('.execution-logs-container');
            if (!logsContainer) {
                // Not on logs tab - store for later
                console.log('Logs container not found, storing log for later');
                pendingLogs.push(log);
                return;
            }

            // Check if this log already exists (to prevent duplicates)
            const existingLog = document.querySelector(`.execution-log-entry[data-log-id="${log.id}"]`);
            if (existingLog) {
                console.log('Log already exists, skipping');
                return;
            }

            // Remove the "no logs" message if it exists
            const noLogsMessage = logsContainer.querySelector('.no-logs-message');
            if (noLogsMessage) {
                noLogsMessage.remove();
            }

            // Create new log entry HTML using the shared render function
            const logHtml = renderLogEntry(log, `new-${log.id}`);

            // Append at the bottom (oldest first, latest at bottom)
            logsContainer.insertAdjacentHTML('beforeend', logHtml);

            // Add a subtle animation to highlight the new log
            const newLogElement = document.querySelector(`.execution-log-entry[data-log-id="${log.id}"]`);
            if (newLogElement) {
                newLogElement.style.backgroundColor = 'rgba(74, 144, 226, 0.1)';
                setTimeout(() => {
                    newLogElement.style.transition = 'background-color 1s ease';
                    newLogElement.style.backgroundColor = '';
                }, 100);
            }

            // Scroll to show the new log
            scrollLogsToBottom();
        }

        function handleStatusChange(status, ticketId) {
            console.log(`Ticket ${ticketId} status changed to: ${status}`);

            // Update the queue status in the table
            updateQueueStatusUI(ticketId, status === 'done' ? 'none' : status);

            // Update the execute button if this is the currently viewed ticket
            if (currentTicket && currentTicket.id === ticketId) {
                const executeBtn = document.getElementById('executeTicketBtn');
                if (executeBtn) {
                    if (status === 'done' || status === 'none') {
                        executeBtn.disabled = false;
                        executeBtn.innerHTML = '<i class="fas fa-hammer"></i> Build Ticket';
                        // Update currentTicket's queue_status
                        currentTicket.queue_status = 'none';
                    } else if (status === 'executing') {
                        executeBtn.disabled = true;
                        executeBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Building...';
                        currentTicket.queue_status = 'executing';
                    } else if (status === 'queued') {
                        executeBtn.disabled = true;
                        executeBtn.innerHTML = '<i class="fas fa-clock"></i> Queued';
                        currentTicket.queue_status = 'queued';
                    }
                }
            }

            // Find the logs container
            const logsContainer = document.querySelector('.execution-logs-container');
            if (!logsContainer) {
                console.log('Logs container not found');
                return;
            }

            // Remove any existing status indicator
            const existingIndicator = document.querySelector('.ticket-status-indicator');
            if (existingIndicator) {
                existingIndicator.remove();
            }

            // Add a status indicator at the top if status is 'done'
            if (status === 'done') {
                const header = logsContainer.querySelector('h4');
                if (header) {
                    const indicator = document.createElement('div');
                    indicator.className = 'ticket-status-indicator';
                    indicator.style.cssText = `
                        background: rgba(34, 197, 94, 0.1);
                        border: 1px solid rgba(34, 197, 94, 0.3);
                        border-radius: 8px;
                        padding: 1rem;
                        margin-bottom: 1rem;
                        display: flex;
                        align-items: center;
                        gap: 0.75rem;
                        animation: slideIn 0.3s ease-out;
                    `;
                    indicator.innerHTML = `
                        <div style="
                            width: 32px;
                            height: 32px;
                            border-radius: 50%;
                            background: rgba(34, 197, 94, 0.2);
                            display: flex;
                            align-items: center;
                            justify-content: center;
                        ">
                            <i class="fas fa-check" style="color: rgb(34, 197, 94); font-size: 18px;"></i>
                        </div>
                        <div>
                            <div style="font-weight: 600; color: rgb(34, 197, 94); margin-bottom: 2px;">Ticket Completed</div>
                            <div style="font-size: 0.875rem; color: var(--text-secondary);">All commands have been executed successfully</div>
                        </div>
                    `;
                    header.insertAdjacentElement('afterend', indicator);
                }
            }
        }

        function switchDrawerTab(tab) {
            currentTab = tab;

            // Keep WebSocket connected even when switching tabs
            // This ensures we don't miss any messages
            // WebSocket will be disconnected only when drawer closes or ticket changes

            // Update tab buttons
            document.querySelectorAll('.drawer-tab').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`.drawer-tab[data-tab="${tab}"]`).classList.add('active');

            // Reload content for current ticket
            if (currentTicket) {
                loadTabContent(tab);
            }
        }

        function loadTabContent(tab) {
            const body = document.getElementById('drawerTicketBody');

            switch(tab) {
                case 'details':
                    showDetailsTab(body);
                    break;
                case 'logs':
                    showLogsTab(body);
                    break;
                case 'tasks':
                    showTasksTab(body);
                    break;
                case 'preview':
                    showPreviewTab(body);
                    break;
            }
        }

        function showDetailsTab(body) {
            const ticket = currentTicket;

            console.log('showDetailsTab called, marked available:', typeof marked !== 'undefined');

            // Helper function to render markdown safely
            const renderMarkdown = (text) => {
                if (!text) return 'No description provided';

                console.log('renderMarkdown called with text:', text.substring(0, 50));
                console.log('marked type:', typeof marked);

                if (typeof marked !== 'undefined') {
                    const result = marked.parse(text);
                    console.log('marked.parse result:', result.substring(0, 100));
                    return result;
                } else {
                    console.warn('marked.js not loaded, using escapeHtml');
                    return escapeHtml(text);
                }
            };

            // Pre-render markdown content
            const descriptionHTML = renderMarkdown(ticket.description);
            const notesHTML = ticket.notes ? renderMarkdown(ticket.notes) : '';
            const attachments = Array.isArray(ticket.attachments) ? ticket.attachments : [];
            const attachmentsHTML = attachments.length ? `
                        <div class="detail-section">
                            <h4>Attachments</h4>
                            <div class="ticket-attachments-grid">
                                ${attachments.map(file => `
                                    <a href="${file.file_url}" class="ticket-attachment-card" target="_blank" rel="noopener noreferrer">
                                        <div class="ticket-attachment-icon">
                                            <i class="fas fa-paperclip"></i>
                                        </div>
                                        <div class="ticket-attachment-info">
                                            <div class="name">${escapeHtml(file.original_filename || 'Attachment')}</div>
                                            <div class="meta">${escapeHtml(file.file_type || 'file')} â€¢ ${formatFileSizeHuman(file.file_size)}</div>
                                        </div>
                                    </a>
                                `).join('')}
                            </div>
                        </div>
                    ` : '';

            // Render acceptance criteria with inline markdown
            const criteriaHTML = ticket.acceptance_criteria && ticket.acceptance_criteria.length > 0
                ? ticket.acceptance_criteria.map(criteria => {
                    const renderedCriteria = typeof marked !== 'undefined' ? marked.parseInline(criteria) : escapeHtml(criteria);
                    return `<li>${renderedCriteria}</li>`;
                }).join('')
                : '';

            body.innerHTML = `
                <div class="ticket-detail-drawer">
                    <div class="detail-meta-row">
                        <select class="compact-select status-select" id="ticketStatus" data-status="${ticket.status}" onchange="updateTicketField('status', this.value)">
                            <option value="open" ${ticket.status === 'open' ? 'selected' : ''}>Open</option>
                            <option value="in_progress" ${ticket.status === 'in_progress' ? 'selected' : ''}>In Progress</option>
                            <option value="done" ${ticket.status === 'done' ? 'selected' : ''}>Done</option>
                            <option value="blocked" ${ticket.status === 'blocked' ? 'selected' : ''}>Blocked</option>
                        </select>

                        <select class="compact-select priority-select" id="ticketPriority" data-priority="${ticket.priority}" onchange="updateTicketField('priority', this.value)">
                            <option value="Low" ${ticket.priority === 'Low' ? 'selected' : ''}>Low</option>
                            <option value="Medium" ${ticket.priority === 'Medium' ? 'selected' : ''}>Medium</option>
                            <option value="High" ${ticket.priority === 'High' ? 'selected' : ''}>High</option>
                        </select>

                        <div class="detail-meta-badge">
                            <i class="fas fa-layer-group"></i> ${ticket.complexity || 'medium'}
                        </div>

                        <div class="detail-meta-badge">
                            <i class="fas fa-calendar"></i> ${formatDate(ticket.created_at)}
                        </div>
                    </div>

                    <div class="detail-section markdown-content">
                        ${descriptionHTML}
                    </div>

                    ${attachmentsHTML}

                    ${criteriaHTML ? `
                        <div class="detail-section">
                            <h4>Acceptance Criteria</h4>
                            <div class="markdown-content">
                                <ul class="criteria-list">
                                    ${criteriaHTML}
                                </ul>
                            </div>
                        </div>
                    ` : ''}

                    ${ticket.notes ? `
                        <div class="detail-section">
                            <h4>Notes</h4>
                            <div class="markdown-content">
                                ${notesHTML}
                            </div>
                        </div>
                    ` : ''}

                    ${ticket.linear_issue_url ? `
                        <div class="detail-section">
                            <h4>Linear Integration</h4>
                            <a href="${ticket.linear_issue_url}" target="_blank" class="btn btn-outline btn-sm">
                                <i class="fas fa-external-link-alt"></i> View in Linear
                            </a>
                        </div>
                    ` : ''}
                </div>
            `;
        }

        async function showLogsTab(body) {
            // Show loading state
            body.innerHTML = `
                <div class="drawer-tab-content logs-tab-content">
                    <div class="empty-logs">
                        <i class="fas fa-spinner fa-spin" style="font-size: 2rem; color: var(--text-secondary); opacity: 0.5;"></i>
                        <p style="color: var(--text-secondary); margin-top: 1rem;">Loading execution logs...</p>
                    </div>
                </div>
            `;

            // Fetch ticket logs
            if (!currentTicket || !currentProjectId) {
                body.innerHTML = `
                    <div class="drawer-tab-content logs-tab-content">
                        <div class="empty-logs">
                            <i class="fas fa-terminal" style="font-size: 2rem; color: var(--text-secondary); opacity: 0.5;"></i>
                            <p style="color: var(--text-secondary); margin-top: 1rem;">No execution logs available.</p>
                        </div>
                    </div>
                `;
                return;
            }

            try {
                // Add cache-busting parameter to avoid stale data
                const cacheBuster = new Date().getTime();
                const response = await fetch(`/api/v1/project-tickets/${currentTicket.id}/logs/?_=${cacheBuster}`);
                const data = await response.json();

                console.log(`[LOGS] Loaded ${data.commands?.length || 0} logs for ticket ${currentTicket.id}`);

                // Log breakdown by type for debugging
                if (data.commands && data.commands.length > 0) {
                    const typeBreakdown = data.commands.reduce((acc, cmd) => {
                        acc[cmd.log_type || 'unknown'] = (acc[cmd.log_type || 'unknown'] || 0) + 1;
                        return acc;
                    }, {});
                    console.log('[LOGS] Type breakdown:', typeBreakdown);
                }

                // Build the logs HTML (oldest first, latest at bottom)
                let logsHtml = '';
                if (data.commands && data.commands.length > 0) {
                    // Keep original order (oldest first)
                    const commands = data.commands;
                    logsHtml = commands.map((cmd, index) => renderLogEntry(cmd, index)).join('');
                }

                // Display logs with chat input at bottom
                body.innerHTML = `
                    <div class="drawer-tab-content logs-tab-content">
                        <div class="execution-logs-container" id="executionLogsContainer">
                            <h4><i class="fas fa-terminal"></i> Command History</h4>
                            ${logsHtml || '<p class="no-logs-message" style="color: var(--text-secondary); font-size: 0.875rem; padding: 1rem 0;">No execution logs yet. Logs will appear here after the ticket is executed.</p>'}
                        </div>
                        <div class="logs-chat-container">
                            <div id="aiTypingIndicatorSlot"></div>
                            <div class="logs-chat-attachments" id="logsChatAttachments"></div>
                            <div class="logs-chat-input-wrapper">
                                <input type="file" id="logsChatFileInput" style="display: none;" multiple onchange="handleLogsChatFileSelect(event)">
                                <div class="logs-chat-field">
                                    <button class="logs-chat-attach-btn" onclick="document.getElementById('logsChatFileInput').click()" title="Attach files">
                                        <i class="fas fa-paperclip"></i>
                                    </button>
                                    <textarea
                                        id="logsChatInput"
                                        class="logs-chat-input"
                                        placeholder="Message AI assistant..."
                                        rows="1"
                                        onkeydown="handleLogsChatKeydown(event)"
                                    ></textarea>
                                    <div class="logs-chat-actions">
                                        <button class="logs-chat-send-btn" id="logsChatSendBtn" onclick="sendLogsChatMessage()" title="Send message">
                                            <i class="fas fa-paper-plane"></i>
                                        </button>
                                        <button class="stop-execution-btn logs-chat-stop-btn" id="logsChatStopBtn" onclick="stopExecution(event)" title="Stop AI execution">
                                            <i class="fas fa-stop"></i>
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                updateSendStopButtons();

                // Process any pending logs that arrived while on other tabs
                if (pendingLogs.length > 0) {
                    console.log(`Processing ${pendingLogs.length} pending logs`);
                    pendingLogs.forEach(log => handleNewLog(log));
                    pendingLogs = [];
                }

                // Restore typing indicator if AI is currently processing
                if (data.is_ai_processing) {
                    console.log('[LOGS] AI is currently processing, showing typing indicator');
                    showAiTypingIndicator();
                }

                // Scroll to bottom to show latest logs
                scrollLogsToBottom();

                // Connect to WebSocket for real-time log updates (if not already connected)
                if (!ticketLogsWebSocket || ticketLogsWebSocket.readyState !== WebSocket.OPEN) {
                    connectTicketLogsWebSocket(currentTicket.id);
                }
            } catch (error) {
                console.error('Error loading logs:', error);
                body.innerHTML = `
                    <div class="drawer-tab-content logs-tab-content">
                        <div class="empty-logs">
                            <i class="fas fa-exclamation-triangle" style="font-size: 2rem; color: var(--error-color); opacity: 0.5;"></i>
                            <p style="color: var(--text-secondary); margin-top: 1rem;">Error loading execution logs.</p>
                        </div>
                    </div>
                `;
            }
        }

        async function showTasksTab(body) {
            // Show loading state
            body.innerHTML = `
                <div class="drawer-tab-content">
                    <div class="empty-logs">
                        <i class="fas fa-spinner fa-spin" style="font-size: 2rem; color: var(--text-secondary); opacity: 0.5;"></i>
                        <p style="color: var(--text-secondary); margin-top: 1rem;">Loading tasks...</p>
                    </div>
                </div>
            `;

            if (!currentTicket || !currentProjectId) {
                body.innerHTML = `
                    <div class="drawer-tab-content">
                        <div class="empty-logs">
                            <i class="fas fa-list-check" style="font-size: 2rem; color: var(--text-secondary); opacity: 0.5;"></i>
                            <p style="color: var(--text-secondary); margin-top: 1rem;">No tasks available.</p>
                        </div>
                    </div>
                `;
                return;
            }

            try {
                const response = await fetch(`/api/v1/project-tickets/${currentTicket.id}/tasks/`);
                const data = await response.json();

                const tasks = data.tasks || (currentTicket.acceptance_criteria || []);

                if (tasks.length === 0) {
                    body.innerHTML = `
                        <div class="drawer-tab-content">
                            <div class="empty-logs">
                                <i class="fas fa-list-check" style="font-size: 2rem; color: var(--text-secondary); opacity: 0.5;"></i>
                                <p style="color: var(--text-secondary); margin-top: 1rem;">No tasks defined for this ticket.</p>
                            </div>
                        </div>
                    `;
                } else {
                    // Check if tasks have structured data (from ProjectTaskList model) or are simple strings
                    const isStructuredTasks = tasks.length > 0 && typeof tasks[0] === 'object';

                    body.innerHTML = `
                        <div class="drawer-tab-content">
                            <div class="tasks-list">
                                ${tasks.map((task, index) => {
                                    if (isStructuredTasks) {
                                        const taskStatus = task.status || 'pending';
                                        const taskText = task.description || 'Unnamed task';
                                        return `
                                            <div class="task-item ${taskStatus}">
                                                <input type="checkbox" id="task-${task.id || index}"
                                                       class="task-checkbox"
                                                       disabled>
                                                <label for="task-${task.id || index}" class="task-label">
                                                    ${escapeHtml(taskText)}
                                                </label>
                                            </div>
                                        `;
                                    } else {
                                        // Simple string tasks from acceptance_criteria
                                        return `
                                            <div class="task-item pending">
                                                <input type="checkbox" id="task-${index}" class="task-checkbox" disabled>
                                                <label for="task-${index}" class="task-label">${escapeHtml(task)}</label>
                                            </div>
                                        `;
                                    }
                                }).join('')}
                            </div>
                        </div>
                    `;
                }
            } catch (error) {
                console.error('Error loading tasks:', error);
                // Fallback to acceptance criteria
                const tasks = currentTicket.acceptance_criteria || [];
                if (tasks.length === 0) {
                    body.innerHTML = `
                        <div class="drawer-tab-content">
                            <div class="empty-logs">
                                <i class="fas fa-list-check" style="font-size: 2rem; color: var(--text-secondary); opacity: 0.5;"></i>
                                <p style="color: var(--text-secondary); margin-top: 1rem;">No tasks defined for this ticket.</p>
                            </div>
                        </div>
                    `;
                } else {
                    body.innerHTML = `
                        <div class="drawer-tab-content">
                            <div class="tasks-list">
                                ${tasks.map((task, index) => `
                                    <div class="task-item pending">
                                        <input type="checkbox" id="task-${index}" class="task-checkbox" disabled>
                                        <label for="task-${index}" class="task-label">${escapeHtml(task)}</label>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                }
            }
        }

        function showTicketModal(ticket) {
            console.log('showTicketModal called with ticket:', ticket);

            // Disconnect existing WebSocket if switching to a different ticket
            if (currentTicket && currentTicket.id !== ticket.id) {
                disconnectTicketLogsWebSocket();
                pendingLogs = [];
            }

            currentTicket = ticket;
            currentProjectId = ticket.project_id;
            currentTab = 'details';
            setAiProcessingState(false);

            // Reset the execute button state based on this ticket's queue status
            const executeBtn = document.getElementById('executeTicketBtn');
            if (executeBtn) {
                const queueStatus = ticket.queue_status || 'none';
                if (queueStatus === 'executing') {
                    executeBtn.disabled = true;
                    executeBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Building...';
                } else if (queueStatus === 'queued') {
                    executeBtn.disabled = true;
                    executeBtn.innerHTML = '<i class="fas fa-clock"></i> Queued';
                } else {
                    executeBtn.disabled = false;
                    executeBtn.innerHTML = '<i class="fas fa-hammer"></i> Build Ticket';
                }
            }

            const drawer = document.getElementById('ticketDrawer');
            const overlay = document.getElementById('ticketDrawerOverlay');
            const title = document.getElementById('drawerTicketTitle');

            console.log('Drawer elements:', {drawer, overlay, title});

            if (!drawer || !overlay) {
                console.error('Drawer elements not found!');
                return;
            }

            title.textContent = `TKT-${ticket.id}: ${ticket.name}`;

            // Reset tabs
            document.querySelectorAll('.drawer-tab').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector('.drawer-tab[data-tab="details"]').classList.add('active');

            // Load details tab
            loadTabContent('details');

            // Pre-connect WebSocket for this ticket (so messages aren't missed)
            connectTicketLogsWebSocket(ticket.id);

            drawer.classList.add('active');
            overlay.classList.add('active');
        }

        function closeTicketDrawer() {
            // Disconnect WebSocket when closing drawer
            disconnectTicketLogsWebSocket();
            pendingLogs = [];

            const drawer = document.getElementById('ticketDrawer');
            const overlay = document.getElementById('ticketDrawerOverlay');
            drawer.classList.remove('active');
            overlay.classList.remove('active');
            setAiProcessingState(false);
            currentTicket = null;
            currentProjectId = null;
        }

        function handleOverlayClick() {
            closeTicketDrawer();
        }

        function closeTicketModal() {
            closeTicketDrawer();
        }

        async function cancelFromQueue(ticketId, projectId) {
            if (!confirm('Remove this ticket from the execution queue?')) {
                return;
            }

            try {
                const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]').value;
                const response = await fetch(`/projects/${projectId}/api/tickets/${ticketId}/cancel-queue/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    }
                });

                const data = await response.json();
                if (data.success) {
                    // Update the queue status cell in the table
                    const queueCell = document.querySelector(`.queue-status-cell[data-ticket-id="${ticketId}"]`);
                    if (queueCell) {
                        queueCell.dataset.queueStatus = 'none';
                        queueCell.innerHTML = '<span class="queue-badge none">-</span>';
                    }

                    // Show success notification if available
                    if (typeof showNotification === 'function') {
                        showNotification('Ticket removed from queue', 'success');
                    }
                } else {
                    alert('Failed to remove from queue: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error canceling from queue:', error);
                alert('Error removing ticket from queue');
            }
        }

        async function forceStopFromQueue(ticketId, projectId) {
            if (!confirm('Force stop this ticket? Use this if the ticket is stuck and the executor has crashed.')) {
                return;
            }

            try {
                const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]').value;
                const response = await fetch(`/projects/${projectId}/api/tickets/${ticketId}/force-reset-queue/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    }
                });

                const data = await response.json();
                if (data.success) {
                    // Update the queue status cell in the table
                    updateQueueStatusUI(ticketId, 'none');

                    // Show success notification if available
                    if (typeof showNotification === 'function') {
                        showNotification('Ticket force stopped', 'success');
                    }
                } else {
                    alert('Failed to force stop: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error force stopping ticket:', error);
                alert('Error force stopping ticket');
            }
        }

        async function restartFromQueue(ticketId, projectId) {
            if (!confirm('Restart this ticket? This will reset its queue status and re-queue it for execution.')) {
                return;
            }

            try {
                const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]').value;
                const response = await fetch(`/projects/${projectId}/api/tickets/${ticketId}/restart-queue/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({
                        conversation_id: 0
                    })
                });

                const data = await response.json();
                if (data.success) {
                    // Update the queue status cell in the table
                    updateQueueStatusUI(ticketId, data.queue_status || 'queued');

                    // Show success notification if available
                    if (typeof showNotification === 'function') {
                        showNotification('Ticket restarted and queued', 'success');
                    }
                } else {
                    alert('Failed to restart ticket: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error restarting ticket:', error);
                alert('Error restarting ticket');
            }
        }

        function updateQueueStatusUI(ticketId, queueStatus) {
            const queueCell = document.querySelector(`.queue-status-cell[data-ticket-id="${ticketId}"]`);
            if (!queueCell) return;

            queueCell.dataset.queueStatus = queueStatus;
            const projectId = queueCell.dataset.projectId;

            if (queueStatus === 'queued') {
                queueCell.innerHTML = `
                    <span class="queue-badge queued">
                        <i class="fas fa-clock"></i> Queued
                    </span>
                    <button class="queue-cancel-btn" onclick="cancelFromQueue(${ticketId}, '${projectId}')" title="Remove from queue">
                        <i class="fas fa-times"></i>
                    </button>
                    <button class="queue-restart-btn" onclick="restartFromQueue(${ticketId}, '${projectId}')" title="Restart ticket">
                        <i class="fas fa-redo"></i>
                    </button>
                `;
            } else if (queueStatus === 'executing') {
                queueCell.innerHTML = `
                    <span class="queue-badge executing">
                        <i class="fas fa-spinner fa-spin"></i> Executing
                    </span>
                    <button class="queue-force-stop-btn" onclick="forceStopFromQueue(${ticketId}, '${projectId}')" title="Force stop (use if stuck)">
                        <i class="fas fa-stop"></i>
                    </button>
                    <button class="queue-restart-btn" onclick="restartFromQueue(${ticketId}, '${projectId}')" title="Force restart">
                        <i class="fas fa-redo"></i>
                    </button>
                `;
            } else {
                queueCell.innerHTML = '<span class="queue-badge none">-</span>';
            }
        }

        async function updateTicketFromTable(selectElement, field) {
            const ticketId = selectElement.dataset.ticketId;
            const projectId = selectElement.dataset.projectId;
            const value = selectElement.value;

            try {
                const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]').value;
                const response = await fetch(`/projects/${projectId}/api/checklist/update/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({
                        item_id: parseInt(ticketId),
                        [field]: value
                    })
                });

                const data = await response.json();
                if (data.success) {
                    // Update the row data attributes
                    const row = selectElement.closest('tr');
                    if (row) {
                        row.dataset[field] = value;
                    }

                    // Update the select element's data attribute for color coding
                    if (field === 'status') {
                        selectElement.dataset.status = value;
                    } else if (field === 'priority') {
                        selectElement.dataset.priority = value;
                    }

                    // If drawer is open for this ticket, update it too
                    if (currentTicket && currentTicket.id === parseInt(ticketId)) {
                        currentTicket[field] = value;
                        const drawerSelect = document.getElementById(field === 'status' ? 'ticketStatus' : 'ticketPriority');
                        if (drawerSelect) {
                            drawerSelect.value = value;
                        }
                    }
                } else {
                    alert('Failed to update ticket: ' + (data.error || 'Unknown error'));
                    // Revert the select to previous value
                    const row = selectElement.closest('tr');
                    if (row) {
                        selectElement.value = row.dataset[field];
                    }
                }
            } catch (error) {
                console.error('Error updating ticket:', error);
                alert('Error updating ticket');
                // Revert the select to previous value
                const row = selectElement.closest('tr');
                if (row) {
                    selectElement.value = row.dataset[field];
                }
            }
        }

        async function updateTicketField(field, value) {
            if (!currentTicket || !currentProjectId) return;

            try {
                const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]').value;
                const response = await fetch(`/projects/${currentProjectId}/api/checklist/update/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({
                        item_id: currentTicket.id,
                        [field]: value
                    })
                });

                const data = await response.json();
                if (data.success) {
                    // Update the current ticket object
                    currentTicket[field] = value;

                    // Update the drawer select's data attribute for color coding
                    const drawerSelect = document.getElementById(field === 'status' ? 'ticketStatus' : 'ticketPriority');
                    if (drawerSelect) {
                        if (field === 'status') {
                            drawerSelect.setAttribute('data-status', value);
                        } else if (field === 'priority') {
                            drawerSelect.setAttribute('data-priority', value);
                        }
                    }

                    // Update the table row
                    const row = document.querySelector(`tr[data-ticket-id="${currentTicket.id}"]`);
                    if (row) {
                        row.dataset[field] = value;

                        // Update the select in the table
                        const selectClass = field === 'status' ? '.status-select' : '.priority-select';
                        const select = row.querySelector(selectClass);
                        if (select) {
                            select.value = value;
                            // Update data attribute for color coding
                            if (field === 'status') {
                                select.setAttribute('data-status', value);
                            } else if (field === 'priority') {
                                select.setAttribute('data-priority', value);
                            }
                        }
                    }
                } else {
                    alert('Failed to update ticket: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error updating ticket:', error);
                alert('Error updating ticket');
            }
        }

        async function executeTicket() {
            if (!currentTicket || !currentProjectId) return;

            const btn = document.getElementById('executeTicketBtn');
            if (!btn) return;

            // Disable button and show loading state
            btn.disabled = true;
            btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Building...';

            try {
                const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]').value;
                const response = await fetch(`/projects/${currentProjectId}/api/tickets/${currentTicket.id}/execute/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({
                        ticket_id: currentTicket.id,
                        conversation_id: ticketConversationId
                    })
                });

                const data = await response.json();
                if (data.success) {
                    // Update queue status in the table
                    const queueStatus = data.queue_status || 'queued';
                    updateQueueStatusUI(currentTicket.id, queueStatus);

                    // Update button to reflect actual queue status
                    if (queueStatus === 'executing') {
                        btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Building...';
                    } else if (queueStatus === 'queued') {
                        btn.innerHTML = '<i class="fas fa-clock"></i> Queued';
                    }
                    // Keep button disabled since ticket is now queued/executing

                    // Update currentTicket's queue_status so it persists when reopening
                    currentTicket.queue_status = queueStatus;

                    // Switch to Logs tab to show execution progress
                    switchDrawerTab('logs');
                } else {
                    alert('Failed to execute ticket: ' + (data.error || 'Unknown error'));
                    // Re-enable button
                    btn.disabled = false;
                    btn.innerHTML = '<i class="fas fa-hammer"></i> Build Ticket';
                }
            } catch (error) {
                console.error('Error executing ticket:', error);
                alert('Error executing ticket: ' + error.message);
                // Re-enable button
                btn.disabled = false;
                btn.innerHTML = '<i class="fas fa-hammer"></i> Build Ticket';
            }
        }

        // Helper functions
        function formatStatus(status) {
            return status.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase());
        }

        function formatDate(dateString) {
            if (!dateString) return 'â€”';
            const date = new Date(dateString);
            return date.toLocaleString('en-US', {
                month: 'short',
                day: 'numeric',
                hour: 'numeric',
                minute: '2-digit',
                second: '2-digit'
            });
        }

        function formatFileSizeHuman(bytes) {
            if (bytes === null || bytes === undefined || isNaN(bytes)) return '0 B';
            const units = ['B', 'KB', 'MB', 'GB', 'TB'];
            let size = bytes;
            let unitIndex = 0;
            while (size >= 1024 && unitIndex < units.length - 1) {
                size /= 1024;
                unitIndex++;
            }
            return `${size.toFixed(size === Math.floor(size) ? 0 : 1)} ${units[unitIndex]}`;
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function sanitizeHtml(html) {
            if (!html) return '';
            const temp = document.createElement('div');
            temp.innerHTML = html;
            temp.querySelectorAll('script, style').forEach(el => el.remove());
            temp.querySelectorAll('*').forEach(el => {
                Array.from(el.attributes).forEach(attr => {
                    const name = attr.name.toLowerCase();
                    const value = (attr.value || '').trim().toLowerCase();
                    if (name.startsWith('on')) {
                        el.removeAttribute(attr.name);
                    } else if ((name === 'href' || name === 'src') && value.startsWith('javascript:')) {
                        el.removeAttribute(attr.name);
                    }
                });
            });
            return temp.innerHTML;
        }

        function renderMarkdown(content) {
            if (!content) return '';
            if (typeof marked === 'undefined') {
                return `<pre>${escapeHtml(content)}</pre>`;
            }
            try {
                const rendered = marked.parse(content);
                return sanitizeHtml(rendered);
            } catch (error) {
                console.error('Error rendering markdown:', error);
                return `<pre>${escapeHtml(content)}</pre>`;
            }
        }

        let previewContent = null; // Cache the preview content
        let shouldAutoStartPreview = true;
        let lastDevServerUrl = null;

        function getPreviewLoadingMarkup(primaryText = 'Loading preview...', secondaryText = "We'll automatically restart the dev server if needed.") {
            return `
                <div class="preview-loading-state" style="
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    height: 100%;
                    color: var(--text-secondary);
                    text-align: center;
                    padding: 2rem;
                ">
                    <i class="fas fa-spinner fa-spin" style="font-size: 1.75rem; opacity: 0.7; margin-bottom: 1rem; color: var(--primary-color, #8b5cf6);"></i>
                    <p style="font-size: 0.95rem; margin: 0;">${primaryText}</p>
                    <p style="font-size: 0.8rem; opacity: 0.65; margin-top: 0.35rem;">${secondaryText}</p>
                </div>
            `;
        }

        async function showPreviewTab(body) {
            if (previewContent && isServerRunning) {
                body.innerHTML = previewContent;
                shouldAutoStartPreview = true;
                updatePreviewLaunchButton(isServerRunning && !!lastDevServerUrl);
                return;
            }

            body.innerHTML = `
                <div class="drawer-tab-content" style="height: 100%; display: flex; flex-direction: column; padding: 0;">
                    <div class="preview-container" style="height: 100%; display: flex; flex-direction: column;">
                        <div class="preview-body" id="previewBody" style="flex: 1; position: relative; background: var(--surface-primary, #0d0d0d);">
                            ${getPreviewLoadingMarkup()}
                        </div>
                    </div>
                </div>
            `;

            if (shouldAutoStartPreview) {
                startDevServer();
            }
            shouldAutoStartPreview = true;
            updatePreviewLaunchButton(false);
        }

        let devServerProcess = null;

        let isServerRunning = false;
        let isStartingDevServer = false;
        let isRestartingDevServer = false;

        async function startDevServer() {
            if (!currentTicket || !currentProjectId) {
                console.error('No ticket selected');
                return;
            }

            if (isStartingDevServer) {
                return;
            }
            isStartingDevServer = true;

            const previewBody = document.getElementById('previewBody');
            updatePreviewLaunchButton(false);

            if (previewBody) {
                previewBody.innerHTML = getPreviewLoadingMarkup('Starting dev server...', 'This usually takes about 20 seconds.');
            }

            try {
                // Kill existing npm processes and start dev server
                const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]').value;
                const response = await fetch(`/api/v1/project-tickets/${currentTicket.id}/start-dev-server/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    credentials: 'include',
                    body: JSON.stringify({
                        project_id: currentProjectId
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to start dev server');
                }

                const data = await response.json();

                // Get the dev server URL from response (supports IPv6)
                const devServerUrl = data.url || 'http://localhost:3000';
                console.log('Dev server started at:', devServerUrl);

                isServerRunning = true;
                lastDevServerUrl = devServerUrl;
                updatePreviewLaunchButton(true);

                if (!previewBody) {
                    console.warn('Preview body element is missing; skipping preview render.');
                    return;
                }

                // Show iframe with preview
                previewBody.innerHTML = `
                    <div style="height: 100%; display: flex; flex-direction: column; position: relative;">
                        <!-- URL Bar with all controls -->
                        <div style="padding: 0.4rem 0.5rem; background: var(--surface-secondary, #1a1a1a); border-bottom: 1px solid var(--border-color, #333); display: flex; align-items: center; gap: 0.5rem;">
                            <input
                                type="text"
                                id="previewUrlInput"
                                value="${devServerUrl}"
                                style="
                                    flex: 1;
                                    background: var(--surface-primary, #0d0d0d);
                                    border: 1px solid var(--border-color, #333);
                                    color: var(--text-primary);
                                    padding: 0.35rem 0.5rem;
                                    border-radius: 4px;
                                    font-size: 0.75rem;
                                    font-family: monospace;
                                    outline: none;
                                "
                                onkeypress="if(event.key === 'Enter') { const iframe = document.getElementById('previewIframe'); iframe.src = this.value; lastDevServerUrl = this.value; updatePreviewLaunchButton(true); }"
                            />
                            <button onclick="document.getElementById('previewIframe').contentWindow.location.reload()" style="
                                background: none;
                                border: 1px solid var(--border-color, #333);
                                color: var(--text-secondary);
                                padding: 0.35rem 0.5rem;
                                border-radius: 4px;
                                cursor: pointer;
                                font-size: 0.75rem;
                            " title="Reload">
                                <i class="fas fa-redo"></i>
                            </button>
                            <button id="serverToggleBtn" onclick="toggleDevServer()" style="
                                background: #e74c3c;
                                border: none;
                                color: white;
                                padding: 0.35rem 0.6rem;
                                border-radius: 4px;
                                cursor: pointer;
                                font-size: 0.75rem;
                            " title="Stop Server">
                                <i class="fas fa-stop"></i>
                            </button>
                            <button onclick="togglePreviewFullscreen()" style="
                                background: none;
                                border: 1px solid var(--border-color, #333);
                                color: var(--text-secondary);
                                padding: 0.35rem 0.5rem;
                                border-radius: 4px;
                                cursor: pointer;
                                font-size: 0.75rem;
                            " title="Fullscreen">
                                <i class="fas fa-expand"></i>
                            </button>
                        </div>

                        <!-- iframe container -->
                        <div id="iframeContainer" style="flex: 1; position: relative; overflow: hidden;">
                            <iframe
                                id="previewIframe"
                                src="${devServerUrl}"
                                style="width: 100%; height: 100%; border: none; background: white;"
                                sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-modals allow-top-navigation allow-top-navigation-by-user-activation"
                            ></iframe>
                        </div>

                        <!-- Console Panel (hidden by default) -->
                        <div id="consolePanel" style="
                            position: absolute;
                            bottom: 0;
                            left: 0;
                            right: 0;
                            height: 0;
                            background: var(--surface-primary, #0d0d0d);
                            border-top: 1px solid var(--border-color, #333);
                            transition: height 0.3s ease;
                            overflow: hidden;
                            display: flex;
                            flex-direction: column;
                        ">
                            <div style="padding: 0.5rem; border-bottom: 1px solid var(--border-color, #333); display: flex; justify-content: space-between; align-items: center;">
                                <span style="font-size: 0.75rem; font-weight: 500; color: var(--text-primary);">
                                    <i class="fas fa-terminal"></i> Console Logs
                                </span>
                                <button onclick="toggleConsole()" style="
                                    background: none;
                                    border: none;
                                    color: var(--text-secondary);
                                    cursor: pointer;
                                    padding: 0.25rem;
                                    font-size: 0.75rem;
                                ">
                                    <i class="fas fa-times"></i>
                                </button>
                            </div>
                            <div id="consoleLogs" style="
                                flex: 1;
                                padding: 0.5rem;
                                overflow-y: auto;
                                font-family: monospace;
                                font-size: 0.7rem;
                                color: var(--text-secondary);
                            ">
                                <div style="opacity: 0.5;">Console logs will appear here...</div>
                            </div>
                        </div>

                        <!-- Console Toggle Button -->
                        <button
                            onclick="toggleConsole()"
                            id="consoleToggleBtn"
                            style="
                                position: absolute;
                                bottom: 0.75rem;
                                right: 0.75rem;
                                background: var(--surface-secondary, #1a1a1a);
                                border: 1px solid var(--border-color, #333);
                                color: var(--text-primary);
                                padding: 0.5rem 0.75rem;
                                border-radius: 6px;
                                cursor: pointer;
                                font-size: 0.75rem;
                                box-shadow: 0 2px 8px rgba(0,0,0,0.3);
                                z-index: 10;
                                display: flex;
                                align-items: center;
                                gap: 0.5rem;
                            "
                        >
                            <i class="fas fa-terminal"></i>
                            Console
                        </button>
                    </div>
                `;

                // Monitor iframe URL changes and update URL bar
                const iframe = document.getElementById('previewIframe');
                const urlInput = document.getElementById('previewUrlInput');

                // Function to update URL bar
                function updateUrlBar() {
                    try {
                        const iframeUrl = iframe.contentWindow.location.href;
                        if (iframeUrl && iframeUrl !== 'about:blank') {
                            urlInput.value = iframeUrl;
                            lastDevServerUrl = iframeUrl;
                            updatePreviewLaunchButton(true);
                        }
                    } catch (e) {
                        // Cross-origin or security error - can't read URL
                        // This is expected for external navigation
                    }
                }

                // Listen for iframe load events
                iframe.addEventListener('load', updateUrlBar);

                // Also poll for URL changes (catches client-side routing)
                let lastUrl = '';
                setInterval(() => {
                    try {
                        const currentUrl = iframe.contentWindow.location.href;
                        if (currentUrl !== lastUrl && currentUrl !== 'about:blank') {
                            lastUrl = currentUrl;
                            urlInput.value = currentUrl;
                            lastDevServerUrl = currentUrl;
                            updatePreviewLaunchButton(true);
                        }
                    } catch (e) {
                        // Ignore cross-origin errors
                    }
                }, 500);

                // Cache the preview content so it can be restored when switching tabs
                const drawerBody = document.getElementById('drawerTicketBody');
                if (drawerBody) {
                    previewContent = drawerBody.innerHTML;
                }

            } catch (error) {
                console.error('Error starting dev server:', error);
                isServerRunning = false;

                if (previewBody) {
                    previewBody.innerHTML = `
                        <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; color: var(--error-color, #ff4444);">
                            <i class="fas fa-exclamation-triangle" style="font-size: 2rem; margin-bottom: 1rem;"></i>
                            <p>Failed to start dev server</p>
                            <p style="font-size: 0.875rem; opacity: 0.7;">${error.message}</p>
                        </div>
                    `;
                }
            } finally {
                isStartingDevServer = false;
                updatePreviewLaunchButton(isServerRunning && !!lastDevServerUrl);
            }
        }

        async function restartDevServer() {
            if (!currentTicket || !currentProjectId || isRestartingDevServer || isStartingDevServer) {
                return;
            }

            const restartBtn = document.getElementById('restartServerBtn');
            const defaultLabel = 'Restart Server';

            isRestartingDevServer = true;

            if (restartBtn) {
                restartBtn.classList.add('loading');
                restartBtn.innerHTML = '<span class="label-dot"></span> Restarting...';
            }

            if (currentTab !== 'preview') {
                shouldAutoStartPreview = false;
                switchDrawerTab('preview');
            }

            const previewBody = document.getElementById('previewBody');
            if (previewBody) {
                previewBody.innerHTML = getPreviewLoadingMarkup('Restarting dev server...', "We'll bring the browser view back as soon as it is ready.");
            }
            updatePreviewLaunchButton(false);

            try {
                if (isServerRunning) {
                    await stopDevServer();
                }
                await startDevServer();
            } catch (error) {
                console.error('Error restarting dev server:', error);
            } finally {
                isRestartingDevServer = false;
                if (restartBtn) {
                    restartBtn.classList.remove('loading');
                    restartBtn.innerHTML = defaultLabel;
                }
            }
        }

        async function toggleDevServer() {
            if (isServerRunning) {
                await stopDevServer();
            } else {
                await startDevServer();
            }
        }

        function updatePreviewLaunchButton(isEnabled) {
            const btn = document.getElementById('openPreviewBtn');
            if (!btn) return;
            btn.disabled = !isEnabled;
            btn.title = isEnabled ? 'Open preview in a new tab' : 'Preview not available yet';
        }

        function openPreviewInNewTab() {
            const fallbackInput = document.getElementById('previewUrlInput');
            const targetUrl = lastDevServerUrl || (fallbackInput ? fallbackInput.value : '');

            if (targetUrl) {
                window.open(targetUrl, '_blank', 'noopener,noreferrer');
            } else {
                alert('Preview URL is not available yet. Restart the server first.');
            }
        }

        async function stopDevServer() {
            if (!currentTicket) return;

            const serverToggleBtn = document.getElementById('serverToggleBtn');
            const previewBody = document.getElementById('previewBody');

            if (serverToggleBtn) {
                serverToggleBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
                serverToggleBtn.disabled = true;
            }

            try {
                const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]').value;
                const response = await fetch(`/api/v1/project-tickets/${currentTicket.id}/stop-dev-server/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    credentials: 'include'
                });

                isServerRunning = false;
                previewContent = null; // Clear cached content when server stops
                updatePreviewLaunchButton(false);

                if (serverToggleBtn) {
                    serverToggleBtn.innerHTML = '<i class="fas fa-play"></i>';
                    serverToggleBtn.disabled = false;
                    serverToggleBtn.style.background = 'var(--accent-color, #4A90E2)';
                    serverToggleBtn.title = 'Start Server';
                }

                if (previewBody) {
                    previewBody.innerHTML = `
                        <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; color: var(--text-secondary);">
                            <i class="fas fa-desktop" style="font-size: 3rem; opacity: 0.3; margin-bottom: 1rem;"></i>
                            <p>Dev server stopped</p>
                            <p style="font-size: 0.875rem; opacity: 0.7;">Use the Restart Server control above to bring it back.</p>
                        </div>
                    `;
                }

            } catch (error) {
                console.error('Error stopping dev server:', error);
                if (serverToggleBtn) {
                    serverToggleBtn.innerHTML = '<i class="fas fa-stop"></i>';
                    serverToggleBtn.disabled = false;
                }
            }
        }

        function togglePreviewFullscreen() {
            const previewContainer = document.querySelector('.preview-container');
            const fullscreenBtn = event.currentTarget;

            if (!document.fullscreenElement) {
                // Enter fullscreen
                if (previewContainer.requestFullscreen) {
                    previewContainer.requestFullscreen();
                } else if (previewContainer.webkitRequestFullscreen) {
                    previewContainer.webkitRequestFullscreen();
                } else if (previewContainer.msRequestFullscreen) {
                    previewContainer.msRequestFullscreen();
                }
                fullscreenBtn.innerHTML = '<i class="fas fa-compress"></i>';
                fullscreenBtn.title = 'Exit Fullscreen';
            } else {
                // Exit fullscreen
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
                fullscreenBtn.innerHTML = '<i class="fas fa-expand"></i>';
                fullscreenBtn.title = 'Toggle Fullscreen';
            }
        }

        // Listen for fullscreen changes to update button icon
        document.addEventListener('fullscreenchange', () => {
            const fullscreenBtn = document.querySelector('[onclick="togglePreviewFullscreen()"]');
            if (fullscreenBtn) {
                if (!document.fullscreenElement) {
                    fullscreenBtn.innerHTML = '<i class="fas fa-expand"></i>';
                    fullscreenBtn.title = 'Toggle Fullscreen';
                }
            }
        });

        function toggleConsole() {
            const consolePanel = document.getElementById('consolePanel');
            const consoleToggleBtn = document.getElementById('consoleToggleBtn');
            const iframeContainer = document.getElementById('iframeContainer');

            if (!consolePanel || !consoleToggleBtn) return;

            const isOpen = consolePanel.style.height !== '0px' && consolePanel.style.height !== '';

            if (isOpen) {
                // Close console
                consolePanel.style.height = '0';
                consoleToggleBtn.style.display = 'flex';
            } else {
                // Open console (40% of container height)
                consolePanel.style.height = '40%';
                consoleToggleBtn.style.display = 'none';

                // Capture console logs from iframe (if same-origin)
                try {
                    const iframe = document.getElementById('previewIframe');
                    const iframeWindow = iframe.contentWindow;
                    const consoleLogs = document.getElementById('consoleLogs');

                    // Override console methods to capture logs
                    const originalLog = iframeWindow.console.log;
                    const originalError = iframeWindow.console.error;
                    const originalWarn = iframeWindow.console.warn;

                    iframeWindow.console.log = function(...args) {
                        originalLog.apply(iframeWindow.console, args);
                        addConsoleLog('log', args);
                    };

                    iframeWindow.console.error = function(...args) {
                        originalError.apply(iframeWindow.console, args);
                        addConsoleLog('error', args);
                    };

                    iframeWindow.console.warn = function(...args) {
                        originalWarn.apply(iframeWindow.console, args);
                        addConsoleLog('warn', args);
                    };

                    function addConsoleLog(type, args) {
                        const timestamp = new Date().toLocaleTimeString();
                        const message = args.map(arg => {
                            if (typeof arg === 'object') {
                                try {
                                    return JSON.stringify(arg, null, 2);
                                } catch (e) {
                                    return String(arg);
                                }
                            }
                            return String(arg);
                        }).join(' ');

                        const colors = {
                            log: 'var(--text-secondary)',
                            error: '#ff4444',
                            warn: '#ffaa00'
                        };

                        const logEntry = document.createElement('div');
                        logEntry.style.marginBottom = '0.25rem';
                        logEntry.style.paddingBottom = '0.25rem';
                        logEntry.style.borderBottom = '1px solid rgba(255,255,255,0.05)';
                        logEntry.innerHTML = `
                            <span style="opacity: 0.5; margin-right: 0.5rem;">${timestamp}</span>
                            <span style="color: ${colors[type]}; font-weight: 500; margin-right: 0.5rem;">[${type.toUpperCase()}]</span>
                            <span style="color: ${colors[type]};">${message}</span>
                        `;

                        consoleLogs.appendChild(logEntry);
                        consoleLogs.scrollTop = consoleLogs.scrollHeight;
                    }

                    consoleLogs.innerHTML = '<div style="opacity: 0.5; margin-bottom: 0.5rem;">Console output will appear here...</div>';
                } catch (e) {
                    // Cross-origin iframe, can't capture logs
                    const consoleLogs = document.getElementById('consoleLogs');
                    consoleLogs.innerHTML = `
                        <div style="color: #ffaa00;">
                            <i class="fas fa-exclamation-triangle"></i>
                            Cannot capture console logs from cross-origin iframe.
                        </div>
                        <div style="opacity: 0.5; margin-top: 0.5rem; font-size: 0.65rem;">
                            Open browser DevTools to view console output.
                        </div>
                    `;
                }
            }
        }

        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }

        function toggleCommandExpand(index) {
            const entry = document.querySelector(`.execution-log-entry[data-cmd-index="${index}"]`);
            if (!entry) return;

            const details = entry.querySelector('.log-details');
            const icon = entry.querySelector('.expand-icon');
            const isExpanded = entry.classList.contains('expanded');

            if (isExpanded) {
                // Collapse
                entry.classList.remove('expanded');
                entry.classList.add('collapsed');
                details.style.display = 'none';
                icon.classList.remove('fa-chevron-down');
                icon.classList.add('fa-chevron-right');
            } else {
                // Expand
                entry.classList.remove('collapsed');
                entry.classList.add('expanded');
                details.style.display = 'block';
                icon.classList.remove('fa-chevron-right');
                icon.classList.add('fa-chevron-down');
            }
        }

        // Close drawer on Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeTicketDrawer();
            }
        });

        // Drawer resize functionality
        (function initDrawerResize() {
            const drawer = document.getElementById('ticketDrawer');
            const resizeHandle = document.getElementById('drawerResizeHandle');
            let isResizing = false;
            let startX = 0;
            let startWidth = 0;
            const minWidth = 500;
            const maxWidth = window.innerWidth - 200;

            // Load saved width from localStorage
            const savedWidth = localStorage.getItem('ticketDrawerWidth');
            if (savedWidth) {
                const width = parseInt(savedWidth);
                if (width >= minWidth && width <= maxWidth) {
                    drawer.style.width = width + 'px';
                }
            }

            resizeHandle.addEventListener('mousedown', function(e) {
                isResizing = true;
                startX = e.clientX;
                startWidth = drawer.offsetWidth;
                drawer.classList.add('resizing');
                resizeHandle.classList.add('active');
                e.preventDefault();
            });

            document.addEventListener('mousemove', function(e) {
                if (!isResizing) return;

                const deltaX = startX - e.clientX;
                const newWidth = Math.min(Math.max(startWidth + deltaX, minWidth), maxWidth);
                drawer.style.width = newWidth + 'px';
            });

            document.addEventListener('mouseup', function() {
                if (isResizing) {
                    isResizing = false;
                    drawer.classList.remove('resizing');
                    resizeHandle.classList.remove('active');
                    // Save width to localStorage
                    localStorage.setItem('ticketDrawerWidth', drawer.offsetWidth);
                }
            });

            // Update max width on window resize
            window.addEventListener('resize', function() {
                const currentWidth = drawer.offsetWidth;
                const newMaxWidth = window.innerWidth - 200;
                if (currentWidth > newMaxWidth) {
                    drawer.style.width = newMaxWidth + 'px';
                    localStorage.setItem('ticketDrawerWidth', newMaxWidth);
                }
            });
        })();

        // WebSocket connection for ticket chat
        let ticketWebSocket = null;
        let ticketConversationId = null;

        function initializeTicketWebSocket() {
            // Generate or get conversation ID
            ticketConversationId = Date.now(); // Simple ID generation for now

            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws/chat/${ticketConversationId}/`;

            ticketWebSocket = new WebSocket(wsUrl);

            ticketWebSocket.onopen = function() {
                console.log('Ticket WebSocket connected');
            };

            ticketWebSocket.onmessage = function(event) {
                const data = JSON.parse(event.data);
                console.log('WebSocket message received:', data);

                if (data.type === 'ticket_chat') {
                    handleTicketChatMessage(data);
                }
            };

            ticketWebSocket.onclose = function() {
                console.log('Ticket WebSocket disconnected');
                // Reconnect after 3 seconds
                setTimeout(initializeTicketWebSocket, 3000);
            };

            ticketWebSocket.onerror = function(error) {
                console.error('Ticket WebSocket error:', error);
            };
        }

        // Test drawer on page load
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Page loaded, checking drawer elements...');
            const drawer = document.getElementById('ticketDrawer');
            const overlay = document.getElementById('ticketDrawerOverlay');
            console.log('Drawer exists:', !!drawer);
            console.log('Overlay exists:', !!overlay);
            if (drawer) {
                console.log('Drawer classes:', drawer.className);
            }
            if (overlay) {
                console.log('Overlay classes:', overlay.className);
            }

            // Initialize WebSocket connection
            initializeTicketWebSocket();
        });
    </script>

    {% csrf_token %}
</body>
</html>
